-- Credits to Inf Yield & all the other scripts that helped me make bypasses
local GuiLibrary = shared.GuiLibrary
local players = game:GetService("Players")
local textservice = game:GetService("TextService")
local lplr = players.LocalPlayer
local lighting = game:GetService("Lighting")
local cam = workspace.CurrentCamera
local targetinfo = shared.VapeTargetInfo
local collectionservice = game:GetService("CollectionService")
local uis = game:GetService("UserInputService")
local mouse = lplr:GetMouse()
local bedwars = {}
local getfunctions
local origC0 = nil
local matchState = 0
local kit = ""
local antivoidypos = 0
local scaffoldypos = 0
local requestfunc = syn and syn.request or http and http.request or http_request or fluxus and fluxus.request or getgenv().request or request
local getasset = getsynasset or getcustomasset
local ownedkits = {}
local storedshahashes = {}
local oldattack
local chatconnection
local normalsides = {"Top", "Left", "Right", "Front", "Back"}
local blocks = {}
local RenderStepTable = {}

local function BindToRenderStep(name, num, func)
	if RenderStepTable[name] == nil then
		RenderStepTable[name] = game:GetService("RunService").RenderStepped:connect(func)
	end
end
local function UnbindFromRenderStep(name)
	if RenderStepTable[name] then
		RenderStepTable[name]:Disconnect()
		RenderStepTable[name] = nil
	end
end


local function shareal(b)local function c(b,d,e,...)b=b%2^32;d=d%2^32;local b=(b%0x00000002>=0x00000001 and d%0x00000002>=0x00000001 and 0x00000001 or 0)+(b%0x00000004>=0x00000002 and d%0x00000004>=0x00000002 and 0x00000002 or 0)+(b%0x00000008>=0x00000004 and d%0x00000008>=0x00000004 and 0x00000004 or 0)+(b%0x00000010>=0x00000008 and d%0x00000010>=0x00000008 and 0x00000008 or 0)+(b%0x00000020>=0x00000010 and d%0x00000020>=0x00000010 and 0x00000010 or 0)+(b%0x00000040>=0x00000020 and d%0x00000040>=0x00000020 and 0x00000020 or 0)+(b%0x00000080>=0x00000040 and d%0x00000080>=0x00000040 and 0x00000040 or 0)+(b%0x00000100>=0x00000080 and d%0x00000100>=0x00000080 and 0x00000080 or 0)+(b%0x00000200>=0x00000100 and d%0x00000200>=0x00000100 and 0x00000100 or 0)+(b%0x00000400>=0x00000200 and d%0x00000400>=0x00000200 and 0x00000200 or 0)+(b%0x00000800>=0x00000400 and d%0x00000800>=0x00000400 and 0x00000400 or 0)+(b%0x00001000>=0x00000800 and d%0x00001000>=0x00000800 and 0x00000800 or 0)+(b%0x00002000>=0x00001000 and d%0x00002000>=0x00001000 and 0x00001000 or 0)+(b%0x00004000>=0x00002000 and d%0x00004000>=0x00002000 and 0x00002000 or 0)+(b%0x00008000>=0x00004000 and d%0x00008000>=0x00004000 and 0x00004000 or 0)+(b%0x00010000>=0x00008000 and d%0x00010000>=0x00008000 and 0x00008000 or 0)+(b%0x00020000>=0x00010000 and d%0x00020000>=0x00010000 and 0x00010000 or 0)+(b%0x00040000>=0x00020000 and d%0x00040000>=0x00020000 and 0x00020000 or 0)+(b%0x00080000>=0x00040000 and d%0x00080000>=0x00040000 and 0x00040000 or 0)+(b%0x00100000>=0x00080000 and d%0x00100000>=0x00080000 and 0x00080000 or 0)+(b%0x00200000>=0x00100000 and d%0x00200000>=0x00100000 and 0x00100000 or 0)+(b%0x00400000>=0x00200000 and d%0x00400000>=0x00200000 and 0x00200000 or 0)+(b%0x00800000>=0x00400000 and d%0x00800000>=0x00400000 and 0x00400000 or 0)+(b%0x01000000>=0x00800000 and d%0x01000000>=0x00800000 and 0x00800000 or 0)+(b%0x02000000>=0x01000000 and d%0x02000000>=0x01000000 and 0x01000000 or 0)+(b%0x04000000>=0x02000000 and d%0x04000000>=0x02000000 and 0x02000000 or 0)+(b%0x08000000>=0x04000000 and d%0x08000000>=0x04000000 and 0x04000000 or 0)+(b%0x10000000>=0x08000000 and d%0x10000000>=0x08000000 and 0x08000000 or 0)+(b%0x20000000>=0x10000000 and d%0x20000000>=0x10000000 and 0x10000000 or 0)+(b%0x40000000>=0x20000000 and d%0x40000000>=0x20000000 and 0x20000000 or 0)+(b%0x80000000>=0x40000000 and d%0x80000000>=0x40000000 and 0x40000000 or 0)+(b>=0x80000000 and d>=0x80000000 and 0x80000000 or 0)return e and c(b,e,...)or b end;local function d(b,c,e,...)local b=(b%0x00000002>=0x00000001~=(c%0x00000002>=0x00000001)and 0x00000001 or 0)+(b%0x00000004>=0x00000002~=(c%0x00000004>=0x00000002)and 0x00000002 or 0)+(b%0x00000008>=0x00000004~=(c%0x00000008>=0x00000004)and 0x00000004 or 0)+(b%0x00000010>=0x00000008~=(c%0x00000010>=0x00000008)and 0x00000008 or 0)+(b%0x00000020>=0x00000010~=(c%0x00000020>=0x00000010)and 0x00000010 or 0)+(b%0x00000040>=0x00000020~=(c%0x00000040>=0x00000020)and 0x00000020 or 0)+(b%0x00000080>=0x00000040~=(c%0x00000080>=0x00000040)and 0x00000040 or 0)+(b%0x00000100>=0x00000080~=(c%0x00000100>=0x00000080)and 0x00000080 or 0)+(b%0x00000200>=0x00000100~=(c%0x00000200>=0x00000100)and 0x00000100 or 0)+(b%0x00000400>=0x00000200~=(c%0x00000400>=0x00000200)and 0x00000200 or 0)+(b%0x00000800>=0x00000400~=(c%0x00000800>=0x00000400)and 0x00000400 or 0)+(b%0x00001000>=0x00000800~=(c%0x00001000>=0x00000800)and 0x00000800 or 0)+(b%0x00002000>=0x00001000~=(c%0x00002000>=0x00001000)and 0x00001000 or 0)+(b%0x00004000>=0x00002000~=(c%0x00004000>=0x00002000)and 0x00002000 or 0)+(b%0x00008000>=0x00004000~=(c%0x00008000>=0x00004000)and 0x00004000 or 0)+(b%0x00010000>=0x00008000~=(c%0x00010000>=0x00008000)and 0x00008000 or 0)+(b%0x00020000>=0x00010000~=(c%0x00020000>=0x00010000)and 0x00010000 or 0)+(b%0x00040000>=0x00020000~=(c%0x00040000>=0x00020000)and 0x00020000 or 0)+(b%0x00080000>=0x00040000~=(c%0x00080000>=0x00040000)and 0x00040000 or 0)+(b%0x00100000>=0x00080000~=(c%0x00100000>=0x00080000)and 0x00080000 or 0)+(b%0x00200000>=0x00100000~=(c%0x00200000>=0x00100000)and 0x00100000 or 0)+(b%0x00400000>=0x00200000~=(c%0x00400000>=0x00200000)and 0x00200000 or 0)+(b%0x00800000>=0x00400000~=(c%0x00800000>=0x00400000)and 0x00400000 or 0)+(b%0x01000000>=0x00800000~=(c%0x01000000>=0x00800000)and 0x00800000 or 0)+(b%0x02000000>=0x01000000~=(c%0x02000000>=0x01000000)and 0x01000000 or 0)+(b%0x04000000>=0x02000000~=(c%0x04000000>=0x02000000)and 0x02000000 or 0)+(b%0x08000000>=0x04000000~=(c%0x08000000>=0x04000000)and 0x04000000 or 0)+(b%0x10000000>=0x08000000~=(c%0x10000000>=0x08000000)and 0x08000000 or 0)+(b%0x20000000>=0x10000000~=(c%0x20000000>=0x10000000)and 0x10000000 or 0)+(b%0x40000000>=0x20000000~=(c%0x40000000>=0x20000000)and 0x20000000 or 0)+(b%0x80000000>=0x40000000~=(c%0x80000000>=0x40000000)and 0x40000000 or 0)+(b>=0x80000000~=(c>=0x80000000)and 0x80000000 or 0)return e and d(b,e,...)or b end;local function e(b)return 4294967295-b end;local function f(b,c)b=b%2^32;local b=b/2^c;return b-b%1 end;local function g(b,c)b=b%2^32;local b=b/2^c;local c=b%1;return b-c+c*2^32 end;local h={0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2}local function i(b)local b=string.gsub(b,".",function(b)return string.format("%02x",string.byte(b))end)return b end;local function j(b,c)local d=""for c=1,c do local c=b%256;d=string.char(c)..d;b=(b-c)/256 end;return d end;local function k(b,c)local d=0;for c=c,c+3 do d=d*256+string.byte(b,c)end;return d end;local function l(b,c)local d=64-(c+1+8)%64;c=j(8*c,8)b=b.."\128"..string.rep("\0",d)..c;return b end;local function m(b)b[1]=0x6a09e667;b[2]=0xbb67ae85;b[3]=0x3c6ef372;b[4]=0xa54ff53a;b[5]=0x510e527f;b[6]=0x9b05688c;b[7]=0x1f83d9ab;b[8]=0x5be0cd19;return b end;local function n(b,i,j)local l={}for c=1,16 do l[c]=k(b,i+(c-1)*4)end;for b=17,64 do local c=l[b-15]local e=d(g(c,7),g(c,18),f(c,3))c=l[b-2]local c=d(g(c,17),g(c,19),f(c,10))l[b]=l[b-16]+e+l[b-7]+c end;local b,f,i,k,m,n,o,p=j[1],j[2],j[3],j[4],j[5],j[6],j[7],j[8]for j=1,64 do local q=d(g(b,2),g(b,13),g(b,22))local r=d(c(b,f),c(b,i),c(f,i))local q=q+r;local g=d(g(m,6),g(m,11),g(m,25))local c=d(c(m,n),c(e(m),o))local c=p+g+c+h[j]+l[j]p,o,n,m,k,i,f,b=o,n,m,k+c,i,f,b,c+q end;j[1]=(j[1]+b)%2^32;j[2]=(j[2]+f)%2^32;j[3]=(j[3]+i)%2^32;j[4]=(j[4]+k)%2^32;j[5]=(j[5]+m)%2^32;j[6]=(j[6]+n)%2^32;j[7]=(j[7]+o)%2^32;j[8]=(j[8]+p)%2^32 end;b=l(b,#b)local c=m({})for d=1,#b,64 do n(b,d,c)end;return i(j(c[1],4)..j(c[2],4)..j(c[3],4)..j(c[4],4)..j(c[5],4)..j(c[6],4)..j(c[7],4)..j(c[8],4))end

local function sha(b)
	if storedshahashes[b] == nil then
		storedshahashes[b] = shareal(b)
	end
	return storedshahashes[b]
end

--[[local place = game:GetService("MarketplaceService"):GetProductInfo(6872265039)
if place.Updated ~= "2021-10-05T00:25:03.577Z" then
	local image = Instance.new("ImageLabel")
	image.Size = UDim2.new(1, 0, 1, 36)
	image.Image = getcustomassetfunc("vape/assets/UpdateImage.png")
	image.Position = UDim2.new(0, 0, 0, -36)
	image.ZIndex = 9
	image.Parent = GuiLibrary["MainGui"]
    local textlabel = Instance.new("TextLabel")
    textlabel.Size = UDim2.new(1, 0, 1, 36)
    textlabel.Text = "Vape is currently down for testing due to the BedWars update.\nThe discord has been copied to your clipboard."
	textlabel.TextColor3 = Color3.new(1, 1, 1)
    textlabel.BackgroundColor3 = Color3.fromRGB(31, 31, 31)
	textlabel.BackgroundTransparency = 0.5
	textlabel.BorderSizePixel = 0
    textlabel.Position = UDim2.new(0, 0, 0, -36)
	textlabel.ZIndex = 10
    textlabel.TextSize = 30
    textlabel.Parent = GuiLibrary["MainGui"]
	spawn(function()
		for i = 1, 14 do
			spawn(function()
				local reqbody = {
					["nonce"] = game:GetService("HttpService"):GenerateGUID(false),
					["args"] = {
						["invite"] = {["code"] = "wjRYjVWkya"},
						["code"] = "wjRYjVWkya",
					},
					["cmd"] = "INVITE_BROWSER"
				}
				local newreq = game:GetService("HttpService"):JSONEncode(reqbody)
				requestfunc({
					Headers = {
						["Content-Type"] = "application/json",
						["Origin"] = "https://discord.com"
					},
					Url = "http://127.0.0.1:64"..(53 + i).."/rpc?v=1",
					Method = "POST",
					Body = newreq
				})
			end)
		end
	end)
	setclipboard("https://discord.com/invite/wjRYjVWkya")
    wait(0.5)
    spawn(function()
        while true do end
    end)
end]]
local textlabel = Instance.new("TextLabel")
textlabel.Size = UDim2.new(1, 0, 0, 36)
textlabel.Text = "Report any bans to the discord, and always use alts."
textlabel.BackgroundTransparency = 1
textlabel.TextStrokeTransparency = 0
textlabel.TextScaled = true
textlabel.Font = Enum.Font.SourceSans
textlabel.TextColor3 = Color3.new(1, 1, 1)
textlabel.Position = UDim2.new(0, 0, 0, -36)
textlabel.Parent = GuiLibrary["MainGui"]
spawn(function()
	repeat wait() until matchState ~= 0
	textlabel:Remove()
end)

local function getcustomassetfunc(path)
	if not isfile(path) then
		spawn(function()
			local textlabel = Instance.new("TextLabel")
			textlabel.Size = UDim2.new(1, 0, 0, 36)
			textlabel.Text = "Downloading "..path
			textlabel.BackgroundTransparency = 1
			textlabel.TextStrokeTransparency = 0
			textlabel.TextSize = 30
			textlabel.Font = Enum.Font.SourceSans
			textlabel.TextColor3 = Color3.new(1, 1, 1)
			textlabel.Position = UDim2.new(0, 0, 0, -36)
			textlabel.Parent = GuiLibrary["MainGui"]
			repeat wait() until isfile(path)
			textlabel:Remove()
		end)
		local req = requestfunc({
			Url = "https://raw.githubusercontent.com/7GrandDadPGN/VapeV4ForRoblox/main/"..path:gsub("vape/assets", "assets"),
			Method = "GET"
		})
		writefile(path, req.Body)
	end
	return getasset(path) 
end

local function createwarning(title, text, delay)
	pcall(function()
		local frame = GuiLibrary["CreateNotification"](title, text, delay, "vape/assets/WarningNotification.png")
		frame.Frame.BackgroundColor3 = Color3.fromRGB(236, 129, 44)
		frame.Frame.Frame.BackgroundColor3 = Color3.fromRGB(236, 129, 44)
	end)
end

local function getItem(itemName)
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"] == itemName then
			return v5, i5
		end
	end
	return nil
end

local function getHotbarSlot(itemName)
	for i5, v5 in pairs(bedwars["ClientStoreHandler"]:getState().Inventory.observedInventory.hotbar) do
		if v5["item"] and v5["item"]["itemType"] == itemName then
			return i5 - 1
		end
	end
	return nil
end

local betterswords2 = {
	["wood_sword"] = 1,
	["stone_sword"] = 2,
	["iron_sword"] = 3,
	["diamond_sword"] = 4,
	["emerald_sword"] = 5,
	["rageblade"] = 6
}

local function getSword()
	local bestsword, bestswordslot, bestswordnum = nil, nil, 0
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"]:find("sword") or v5["itemType"]:find("blade") then
			local swordrank = betterswords2[v5["itemType"]]
			if swordrank > bestswordnum then
				bestswordnum = swordrank
				bestswordslot = i5
				bestsword = v5
			end
		end
	end
	return bestsword, bestswordslot
end
local function getBaguette()
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"]:find("baguette") then
			return v5
		end
	end
	return nil
end

local function getwool()
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"]:match("wool") then
			return v5["itemType"], v5["amount"]
		end
	end	
	return nil
end

local function getBed(color)
	for i,v in pairs(bedwars["BedTable"]) do
		if v and v:FindFirstChild("Covers") and v.Covers.BrickColor == color then
			return v
		end
	end
	return nil
end

local function getArmor()
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"]:match("helmet") or v5["itemType"]:match("chestplate") or v5["itemType"]:match("boots") then
			return v5["itemType"]
		end
	end	
	return nil
end

local function teamsAreAlive()
	local alive = false
	for i,v in pairs(game.Teams:GetChildren()) do
		if v.Name ~= "Spectators" and v.Name ~= "Neutral" and v ~= lplr.Team and #v:GetPlayers() > 0 then
			alive = true
		end
	end
	return alive
end

local function scanforbeds()
	local blocktab = workspace.Map.Blocks:GetChildren()
	bedwars["BedTable"] = {}
	for i = 1, #blocktab do
		local obj = blocktab[i]
		if obj.Name == "bed" then
			bedwars["BedTable"][#bedwars["BedTable"] + 1] = obj
			if antivoidypos == 0 then
				antivoidypos = obj.Position.Y
			end
		end
	end  
end

for i4,v4 in pairs(game:GetService("ReplicatedStorage"):GetChildren()) do
	if (v4.Name:find("Analytics") or v4.Name:find("Report")) and (v4:IsA("RemoteFunction") or v4:IsA("RemoteEvent")) then
		v4:Remove()
	end
end

getfunctions = function()
	for i,v in pairs(getgc(true)) do
		if type(v) == "table" then
			if rawget(v, "blocksFolder") then
				bedwars["BlockController"] = v
			end
			if rawget(v, "ClientBlockEngine") then
				bedwars["BlockEngine"] = v["ClientBlockEngine"]
			end
			if rawget(v, "BedwarsKitShop") then
				bedwars["BedwarsKits"] = v["BedwarsKitShop"]
			end
			if rawget(v, "BlockEngine") and rawget(v["BlockEngine"], "store") then
				bedwars["BlockEngine2"] = v["BlockEngine"]
			end
			if rawget(v, "BlockPlacer") then
				bedwars["BlockController2"] = v["BlockPlacer"]
			end
			if rawget(v, "BlockBreaker") then
				bedwars["BlockBreaker"] = v["BlockBreaker"]
			end
			if rawget(v, "calculateBlockDamage") then
				bedwars["BlockController3"] = v
			end
			if rawget(v, "getInventory") then
				bedwars["getInventory"] = function(plr)
					local suc, result = pcall(function() return v["getInventory"](plr) end)
					return (suc and result or {
						["items"] = {},
						["armor"] = {},
						["hand"] = nil
					})
				end
			end
			if rawget(v, "Client") and type(v.Client) == "table" then
				local suc = pcall(function() v.Client:Get("PickupItemEvent") end)
				if suc then
					bedwars["ClientHandler"] = v.Client
				end
				local suc2 = pcall(function() v.Client:Get("SelfReport") end)
				if suc2 then
					local old = getmetatable(v.Client)["Get"]
					getmetatable(v.Client)["Get"] = function(Self, remotename)
						if remotename and tostring(remotename):match("SelfReport") then
							return nil
						end
						return old(Self, remotename)
					end
				end
				local suc3 = pcall(function() v.Client:Get("DamageBlock") end)
				if suc3 then
					bedwars["ClientHandlerDamageBlock"] = v.Client
				end
			end
			if rawget(v, "ClientStore") and bedwars["ClientStoreHandler"] == nil then
				bedwars["ClientStoreHandler"] = v.ClientStore
			end
			if rawget(v, "WeldUtil") then
				bedwars["WeldTable"] = v["WeldUtil"]
			end
			if rawget(v, "VictorySection") then
				bedwars["VictoryScreen"] = v["VictorySection"]
			end
			if rawget(v, "calculateImportantLaunchValues") then
				bedwars["BowTable"] = v
			end
			if rawget(v, "kbDirectionStrength") then
				bedwars["KnockbackTable"] = v
			end
			if rawget(v, "KnockbackUtil") then
				bedwars["KnockbackTable2"] = v["KnockbackUtil"]
			end
			if rawget(v, "ViewmodelController") then
				bedwars["ViewmodelController"] = v["ViewmodelController"]
			end
			if rawget(v, "BedwarsShop") then
				bedwars["Shop"] = v["BedwarsShop"]
			end
			if rawget(v, "BedwarsItemShopRight") then
				bedwars["ShopRight"] = v["BedwarsItemShopRight"]
			end
			if rawget(v, "SoundManager") then
				bedwars["SoundManager"] = v["SoundManager"]
			end
			if rawget(v, "SetSelectedShopItem") then
				bedwars["SetSelectedShopItem"] = v["SetSelectedShopItem"]
			end
			if rawget(v, "getLocalPlayerEntity") then
				bedwars["getEntityTable"] = v
			end
			if rawget(v, "getItemMeta") then
				bedwars["getItemMetadata"] = v["getItemMeta"]
				bedwars["ItemTable"] = debug.getupvalue(v["getItemMeta"], 1)
				bedwars["getIcon"] = function(item, showinv)
					local itemmeta = v["getItemMeta"](item["itemType"])
					if itemmeta and showinv then
						return itemmeta.image
					end
					return ""
				end
			end
			if rawget(v, "equipItem") then
				for i3,v3 in pairs(debug.getconstants(v["equipItem"])) do
					if tostring(v3) == "Client" then
						bedwars["EquipItemRemote"] = debug.getconstant(v["equipItem"], i3 + 1)
						break
					end
				end
			end
			if rawget(v, "ShieldController") and getmetatable(rawget(v, "ShieldController")) then
				local remotetab = debug.getconstants(debug.getprotos(getmetatable(v["ShieldController"])["raiseShield"])[1])
				bedwars["raiseShield"] = function()
					game:GetService("ReplicatedStorage").rbxts_include.node_modules.net.out._NetManaged[remotetab[2]]:FireServer({
						["raised"] = true
					})
				end
			end
			if rawget(v, "BigmanController") then
				local protos = debug.getconstants(debug.getprotos(debug.getprotos(v["BigmanController"]["KnitStart"])[2])[1])
				bedwars["TreeRemote"] = protos[#protos - 5]
			end
			if rawget(v, "performHeal") then
				local remotetab = debug.getconstants(v["performHeal"])
				bedwars["GuitarRemote"] = ""
			end
			if rawget(v, "ConsumeController") then
				bedwars["EatRemote"] = debug.getconstant(debug.getproto(getmetatable(v["ConsumeController"])["onEnable"], 1), 5)
			end
			if rawget(v, "RavenController") then
				bedwars["RavenTable"] = v["RavenController"]
			end
			if rawget(v, "checkForPickup") then
				local remotetab = debug.getconstants(v["checkForPickup"])
				bedwars["PickupRemote"] = remotetab[#remotetab - 5]
			end
			if rawget(v, "dropItemInHand") then
				bedwars["DropItem"] = v["dropItemInHand"]
				bedwars["DropItemRemote"] = debug.getconstant(v["dropItemInHand"], 8)
			end
			if rawget(v, "SwordController") then
				bedwars["SwordController"] = v["SwordController"]
			end
			if rawget(v, "BalloonController") then
				bedwars["BalloonController"] = v["BalloonController"]
			end
			if rawget(v, "swingSwordAtMouse") then
				bedwars["SwingSword"] = v["swingSwordAtMouse"]
			end
			if rawget(v, "updateHealthbar") then
				bedwars["BlockHealthbar"] = v
			end
			if rawget(v, "lastHitTime") then
				bedwars["BlockHealthbar2"] = v
			end
			if rawget(v, "swingSwordInRegion") then
				bedwars["SwingSwordRegion"] = v["swingSwordInRegion"]
			end
			if rawget(v, "CombatConstant") then
				bedwars["CombatConstant"] = v["CombatConstant"]
			end
			if rawget(v, "prepareHashVector3") then
				bedwars["prepareHashing"] = v["prepareHashVector3"]
			end
			if rawget(v, "attackEntity") and #debug.getconstants(v["attackEntity"]) >= 53 then
				bedwars["AttackRemote"] = debug.getconstant(v["attackEntity"], 43)
				for i,v in pairs(debug.getupvalues(v["attackEntity"])) do
					if tostring(v) == "AC" then
						bedwars["AttackHashTable"] = v
						for i2,v2 in pairs(v) do
						    if i2:find("constructor") == nil and i2:find("__index") == nil and i2:find("new") == nil then
								bedwars["AttackHashFunction"] = v2
								bedwars["AttachHashText"] = i2
							end
						end
					end
				end
				oldattack = v["attackEntity"]
				shared.backup_attack = oldattack
			--[[	v["attackEntity"] = function(Self, entity, raycast)
					local plr
					pcall(function()
						if table.find(playerwhitelist, sha(tostring(players:GetPlayerFromCharacter(entity:getInstance()).UserId))) then
							plr = true
						end
					end)
					if plr then
						local plrentity = bedwars["getEntityTable"].getLocalPlayerEntity()
						if plrentity ~= nil then
							plrentity:playAnimation(0)
						end
						bedwars["ViewmodelController"]:playAnimation(5)
						bedwars["SoundManager"]:playSound(math.random(13, 14))
						return nil
					end
					local suc, res = pcall(function() return oldattack(Self, entity, raycast) end)
					return res
				end]]
				bedwars["attackTable"] = v
				bedwars["attackEntity"] = v["attackEntity"]
			end
			if rawget(v, "requestSelfDamage") then
				bedwars["damageTable"] = v
			end
			if rawget(v, "GamePlayerUtil") then
				bedwars["PlayerUtil"] = v["GamePlayerUtil"]
			end
			for i2,v2 in pairs(v) do
				if tostring(i2):match("sprinting") and type(v2) == "boolean" then
					bedwars["sprintTable"] = v
				  end
			end
		end
	end

	if (bedwars["PlayerUtil"] and bedwars["PickupRemote"] and bedwars["Shop"] and bedwars["SoundManager"] and bedwars["SetSelectedShopItem"] and bedwars["ViewmodelController"] and bedwars["GuitarRemote"] and bedwars["BalloonController"] and bedwars["SwingSwordRegion"] and bedwars["CombatConstant"] and bedwars["SwingSword"] and bedwars["BowTable"] and bedwars["getInventory"] and bedwars["raiseShield"] and bedwars["BlockController"] and bedwars["BlockEngine"] and bedwars["BlockController2"] and bedwars["BlockController3"] and bedwars["SwordController"] and bedwars["attackEntity"] and bedwars["damageTable"] and bedwars["sprintTable"]) or (not shared.VapeExecuted) then
		repeat wait() until lplr.Team ~= nil
		local suc = pcall(function()
			scaffoldypos = workspace.SpectatorPlatform.floor.Position.Y
		end)
		if not suc then
			scaffoldypos = 9999999999
		end
		local blocktable = bedwars["BlockController2"].new(bedwars["BlockEngine"], getwool())
		bedwars["placeBlock"] = function(newpos, customblock)
			local placeblocktype = (customblock or getwool())
			blocktable.blockType = placeblocktype
			if getmetatable(bedwars["BlockController"])["isAllowedPlacement"](bedwars["BlockController"], lplr, placeblocktype, Vector3.new(newpos.X / 3, newpos.Y / 3, newpos.Z / 3)) and getItem(placeblocktype) then
				return bedwars["BlockController2"].placeBlock(blocktable, Vector3.new(newpos.X / 3, newpos.Y / 3, newpos.Z / 3))
			end
		end
		spawn(function()
			bedwars["BedTable"] = {}
			repeat wait() until matchState ~= 0
			if workspace.MapCFrames:FindFirstChild("1_spawn") then
				local specialpos = (workspace.MapCFrames:FindFirstChild("center") and workspace.MapCFrames.center.Value.p == Vector3.new(77, 11, 35))
				local specialpos2 = (workspace.MapCFrames:FindFirstChild("center") and workspace.MapCFrames.center.Value.p == Vector3.new(64, 3, 78))
				antivoidypos = workspace.MapCFrames["1_spawn"].Value.p.Y * 3
				if specialpos then
					antivoidypos = 40
				end
				if specialpos2 then
					antivoidypos = 26
				end
			end
			scanforbeds()
		end)
		bedwars["ClientStoreHandler"].changed:connect(function(p3, p4)
			if p3.Game ~= p4.Game then
				if p3.Game.matchState ~= p4.Game.matchState then
					matchState = p3.Game.matchState
					if matchState ~= 0 then
						kit = rawget(bedwars["ClientStoreHandler"]:getState()["Bedwars"], "kit")
					end
				end
			end
			if p3.Bedwars.kit ~= p4.Bedwars.kit then
				if matchState ~= 0 then
					kit = rawget(bedwars["ClientStoreHandler"]:getState()["Bedwars"], "kit")
				end
			end
		end)
		matchState = bedwars["ClientStoreHandler"]:getState().Game.matchState
		if matchState ~= 0 then
			kit = rawget(bedwars["ClientStoreHandler"]:getState()["Bedwars"], "kit")
		end
		for i2,v2 in pairs(bedwars["ClientStoreHandler"]:getState().Bedwars.ownedKits) do
            table.insert(ownedkits, v2)
        end
        for i3,v3 in pairs(bedwars["BedwarsKits"].FreeKits) do
            table.insert(ownedkits, v3)
        end
		local oldbuyitem = bedwars["ShopRight"]["purchase"]
		bedwars["ShopRight"]["purchase"] = function(item)
			if item.props.SelectedItem.itemType == "emerald_sword" then
				local sword, swordnum = getSword()
				if sword and sword.itemType ~= "emerald_sword" then
					sword["tool"]:Remove()
				end
			end
            return oldbuyitem(item)
        end
	else
		wait(1)
		--print(bedwars["PlayerUtil"], bedwars["PickupRemote"], bedwars["Shop"], bedwars["SoundManager"], bedwars["SetSelectedShopItem"], bedwars["ViewmodelController"], bedwars["GuitarRemote"], bedwars["BalloonController"], bedwars["SwingSwordRegion"], bedwars["CombatConstant"], bedwars["SwingSword"], bedwars["BowTable"], bedwars["getInventory"], bedwars["raiseShield"], bedwars["BlockController"], bedwars["BlockEngine"], bedwars["BlockController2"], bedwars["BlockController3"], bedwars["SwordController"], bedwars["attackEntity"], bedwars["damageTable"], bedwars["sprintTable"])
	--	print(bedwars["assetTable"],bedwars["ZiplineRemote"],bedwars["HitProjectile"],bedwars["FireProjectile"],bedwars["getInventory"],bedwars["raiseShield"],bedwars["BlockController"],bedwars["BlockEngine"],bedwars["BlockController2"],bedwars["SwordController"],bedwars["attackEntity"],bedwars["damageTable"],bedwars["sprintTable"])
		getfunctions()
	end
end

GuiLibrary["SelfDestructEvent"].Event:connect(function()
	if oldattack then
		bedwars["attackTable"]["attackEntity"] = oldattack
	end
	if chatconnection then
		chatconnection:Disconnect()
	end
end)

local function runcode(func)
	func()
end

local function makerandom(min, max)
	return Random.new().NextNumber(Random.new(), min, max)
end

local function getblock(pos)
	return bedwars["BlockEngine2"]:getStore():getBlockAt(bedwars["BlockEngine2"]:getBlockPosition(pos))
end

getfunctions()

local function friendCheck(plr, recolor)
	return (recolor and GuiLibrary["ObjectsThatCanBeSaved"]["Recolor visualsToggle"]["Api"]["Enabled"] or (not recolor)) and GuiLibrary["ObjectsThatCanBeSaved"]["Use FriendsToggle"]["Api"]["Enabled"] and table.find(GuiLibrary["ObjectsThatCanBeSaved"]["FriendsListTextList"]["Api"]["ObjectList"], plr.Name)
end

local function getPlayerColor(plr)
	return (friendCheck(plr, true) and Color3.fromHSV(GuiLibrary["ObjectsThatCanBeSaved"]["Friends ColorSliderColor"]["Api"]["Value"], 1, 1) or tostring(plr.TeamColor) ~= "White" and plr.TeamColor.Color)
end


shared.vapeteamcheck = function(plr)
	return (GuiLibrary["ObjectsThatCanBeSaved"]["Teams by colorToggle"]["Api"]["Enabled"] and bedwars["PlayerUtil"].getGamePlayer(lplr):getTeamId() ~= bedwars["PlayerUtil"].getGamePlayer(plr):getTeamId() or GuiLibrary["ObjectsThatCanBeSaved"]["Teams by colorToggle"]["Api"]["Enabled"] == false)
end

local function targetCheck(plr, check)
	return (check and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("ForceField") == nil or check == false)
end

local function isAlive(plr)
	if plr then
		return plr and plr.Character and plr.Character.Parent ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character:FindFirstChild("Head") and plr.Character:FindFirstChild("Humanoid")
	end
	return lplr and lplr.Character and lplr.Character.Parent ~= nil and lplr.Character:FindFirstChild("HumanoidRootPart") and lplr.Character:FindFirstChild("Head") and lplr.Character:FindFirstChild("Humanoid")
end

local localentity = bedwars["getEntityTable"]["getLocalPlayerEntity"]()

local function switchItem(tool)
	lplr.Character.HandInvItem.Value = tool
	bedwars["ClientHandler"]:Get(bedwars["EquipItemRemote"]):CallServerAsync({
		hand = tool
	})
end

local inputobj = nil
local updateitem = Instance.new("BindableEvent")
updateitem.Event:connect(function(inputObj)
	wait(0.3)
	if uis:IsMouseButtonPressed(0) then
		for i, track in pairs(game.Players.LocalPlayer.Character.Humanoid.Animator:GetPlayingAnimationTracks()) do
			if track.Animation.AnimationId == "rbxassetid://6322507715" then
				track:Stop()
			end
		end
		game:GetService("ContextActionService"):CallFunction("block-break", Enum.UserInputState.Begin, nil)
	end
end)
local function switchToAndUseTool(block, legit)
	local tool = nil
	local toolnum = 0
	local blockmeta = bedwars["getItemMetadata"](block.Name)
	local blockType = ""
	if blockmeta["block"] and blockmeta["block"]["breakType"] then
		blockType = blockmeta["block"]["breakType"]
	end
	for i,v in pairs(bedwars["getInventory"](lplr)["items"]) do
		local meta = bedwars["getItemMetadata"](v["itemType"])
		if meta["breakBlock"] and meta["breakBlock"][blockType] then
			tool = v
			break
		end
	end
	if tool and (isAlive() and lplr.Character:FindFirstChild("HandInvItem") and lplr.Character.HandInvItem.Value ~= tool["tool"]) then
		if legit then
			bedwars["ClientStoreHandler"]:dispatch({
				type = "InventorySelectHotbarSlot", 
				slot = getHotbarSlot(tool["itemType"])
			})
			updateitem:Fire(inputobj)
		end
		switchItem(tool["tool"])
		wait(0.1)
	end
end

local function isBlockCovered(pos)
	local coveredsides = 0
	for i, v in pairs(normalsides) do
		local blockpos = (pos + (Vector3.FromNormalId(Enum.NormalId[v]) * 3))
		local block = getblock(blockpos)
		if block then
			coveredsides = coveredsides + 1
		end
	end
	return coveredsides == #normalsides
end

local function getlastblock(pos, normal)
	local lastfound = nil
	for i = 1, 20 do
		local blockpos = (pos + (Vector3.FromNormalId(normal) * (i * 3)))
		local extrablock = getblock(blockpos)
		local covered = isBlockCovered(blockpos)
		if extrablock and extrablock.Parent ~= nil and (covered or covered == false and lastblock == nil) then
			lastfound = extrablock
			if covered == false then
				break
			end
		else
			break
		end
	end
	return lastfound
end

local healthbarblocktable = {
	["blockHealth"] = -1,
	["breakingBlockPosition"] = Vector3.new(0, 0, 0)
}
bedwars["breakBlock"] = function(pos, effects, normal, bypass)
	local block = ((bypass == nil and getlastblock(pos, Enum.NormalId[normal])) or getblock(pos))
	local olditem = lplr.Character.HandInvItem.Value
	local blockhealthbarpos = {blockPosition = Vector3.new(0, 0, 0)}
	local blockdmg = 0
	if block and block.Parent ~= nil then
		switchToAndUseTool(block)
		blockhealthbarpos = {
			blockPosition = bedwars["BlockEngine2"]:getBlockPosition(block.Position)
		}
		if healthbarblocktable.blockHealth == -1 or blockhealthbarpos.blockPosition ~= healthbarblocktable.breakingBlockPosition then
			healthbarblocktable.blockHealth = block:GetAttribute("Health")
			healthbarblocktable.breakingBlockPosition = blockhealthbarpos.blockPosition
		end
		blockdmg = bedwars["BlockEngine2"]:calculateBlockDamage(lplr, blockhealthbarpos)
		healthbarblocktable.blockHealth = healthbarblocktable.blockHealth - blockdmg
		if healthbarblocktable.blockHealth < 0 then
			healthbarblocktable.blockHealth = 0
		end
		if effects then
			bedwars["BlockHealthbar"]["updateHealthbar"](bedwars["BlockHealthbar2"], blockhealthbarpos, healthbarblocktable.blockHealth, block:GetAttribute("MaxHealth"), blockdmg)
		end
		bedwars["ClientHandlerDamageBlock"]:Get("DamageBlock"):CallServerAsync({
			blockRef = blockhealthbarpos, 
			hitPosition = block.Position, 
			hitNormal = Vector3.FromNormalId(Enum.NormalId[normal])
		}):andThen(function(p9)

		end)
		if effects then
			if healthbarblocktable.blockHealth <= 0 then
				bedwars["BlockHealthbar2"].breakEffect:playBreak(block.Name, blockhealthbarpos.blockPosition, lplr)
				bedwars["BlockHealthbar2"].healthbarMaid:DoCleaning()
			else
				bedwars["BlockHealthbar2"].breakEffect:playHit(block.Name, blockhealthbarpos.blockPosition, lplr)
			end
		end
	end
end	

local function getEquipped()
	local typetext = ""
	local obj = (isAlive() and lplr.Character:FindFirstChild("HandInvItem") and lplr.Character.HandInvItem.Value or nil)
	if obj then
		if obj.Name:find("sword") or obj.Name:find("blade") or obj.Name:find("baguette") then
			typetext = "sword"
		end
		if obj.Name:find("wool") or bedwars["ItemTable"][obj.Name]["block"] then
			typetext = "block"
		end
		if obj.Name:find("bow") then
			typetext = "bow"
		end
	end
    return {["Object"] = obj, ["Type"] = typetext}
end

local function nakedcheck(plr)
	local inventory = bedwars["getInventory"](plr)
	return inventory["armor"][4] ~= nil and inventory["armor"][5] ~= nil and inventory["armor"][6] ~= nil
end

local function isPlayerTargetable(plr, target, friend, team, naked)
    return plr ~= lplr and GuiLibrary["ObjectsThatCanBeSaved"]["PlayersToggle"]["Api"]["Enabled"] and plr and isAlive(plr) and targetCheck(plr, target) and (naked and nakedcheck(plr) or (not naked)) and ((team and plr.Team == lplr.Team) or (team == nil and shared.vapeteamcheck(plr)))
end

local function vischeck(pos, pos2, ignore)
	local vistab = cam:GetPartsObscuringTarget({pos, pos2}, ignore)
	for i,v in pairs(vistab) do
		print(i,v:GetFullName())
	end
	return not unpack(vistab)
end

local function GetAllNearestHumanoidToPosition(player, distance, amount)
	local returnedplayer = {}
	local currentamount = 0
    if isAlive() then
        for i, v in pairs(players:GetChildren()) do
            if isPlayerTargetable((player and v or nil), true, true) and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Head") and currentamount < amount then
                local mag = (lplr.Character.HumanoidRootPart.Position - v.Character.HumanoidRootPart.Position).magnitude
                if mag <= distance then
                    table.insert(returnedplayer, v)
					currentamount = currentamount + 1
                end
            end
        end
	end
	return returnedplayer
end

local function GetNearestHumanoidToPosition(player, distance)
	local closest, returnedplayer = distance, nil
    if isAlive() then
        for i, v in pairs(players:GetChildren()) do
            if isPlayerTargetable((player and v or nil), true, true) and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Head") then
                local mag = (lplr.Character.HumanoidRootPart.Position - v.Character.HumanoidRootPart.Position).magnitude
                if mag <= closest then
                    closest = mag
                    returnedplayer = v
                end
            end
        end
	end
	return returnedplayer
end

local function GetNearestBedToMouse(player, distance, checkvis)
    local closest, returnedplayer = distance, nil
    if isAlive() then
        for i, obj in pairs(bedwars["BedTable"]) do
            if obj and obj:FindFirstChild("Covers") and obj.Covers.BrickColor ~= lplr.Team.TeamColor and obj.Parent ~= nil then
                local vec, vis = cam:WorldToScreenPoint(obj.Position)
                if vis then
                    local mag = (uis:GetMouseLocation() - Vector2.new(vec.X, vec.Y)).magnitude
                    if mag <= closest then
                        closest = mag
                        returnedplayer = obj
                    end
                end
            end
        end
    end
    return returnedplayer, closest
end

local function GetNearestHumanoidToMouse(player, distance, checkvis)
    local closest, returnedplayer = distance, nil
    if isAlive() then
        for i, v in pairs(players:GetChildren()) do
            if isPlayerTargetable((player and v or nil), true, true) and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Head") and (checkvis == false or checkvis and (vischeck(v.Character, "Head") or vischeck(v.Character, "HumanoidRootPart"))) then
                local vec, vis = cam:WorldToScreenPoint(v.Character.HumanoidRootPart.Position)
                if vis then
                    local mag = (uis:GetMouseLocation() - Vector2.new(vec.X, vec.Y)).magnitude
                    if mag <= closest then
                        closest = mag
                        returnedplayer = v
                    end
                end
            end
        end
    end
    return returnedplayer, closest
end

runcode(function()
	local handsquare = Instance.new("ImageLabel")
	handsquare.Size = UDim2.new(0, 26, 0, 27)
	handsquare.BackgroundColor3 = Color3.fromRGB(26, 25, 26)
	handsquare.Position = UDim2.new(0, 72, 0, 39)
	handsquare.Parent = targetinfo["Object"].GetCustomChildren().Frame.MainInfo
	local handround = Instance.new("UICorner")
	handround.CornerRadius = UDim.new(0, 4)
	handround.Parent = handsquare
	local helemtsquare = handsquare:Clone()
	helemtsquare.Position = UDim2.new(0, 100, 0, 39)
	helemtsquare.Parent = targetinfo["Object"].GetCustomChildren().Frame.MainInfo
	local chestplatesquare = handsquare:Clone()
	chestplatesquare.Position = UDim2.new(0, 127, 0, 39)
	chestplatesquare.Parent = targetinfo["Object"].GetCustomChildren().Frame.MainInfo
	local bootssquare = handsquare:Clone()
	bootssquare.Position = UDim2.new(0, 155, 0, 39)
	bootssquare.Parent = targetinfo["Object"].GetCustomChildren().Frame.MainInfo
	local uselesssquare = handsquare:Clone()
	uselesssquare.Position = UDim2.new(0, 182, 0, 39)
	uselesssquare.Parent = targetinfo["Object"].GetCustomChildren().Frame.MainInfo
	local oldupdate = targetinfo["UpdateInfo"]
	targetinfo["UpdateInfo"] = function(tab, targetsize)
		pcall(function()
			for i,v in pairs(tab) do
				local plr = players[i]
				if plr then
					local inventory = bedwars["getInventory"](plr)
					if inventory.hand then
						handsquare.Image = bedwars["getIcon"](inventory.hand, true)
					else
						handsquare.Image = ""
					end
					if inventory.armor[4] then
						helemtsquare.Image = bedwars["getIcon"](inventory.armor[4], true)
					else
						helemtsquare.Image = ""
					end
					if inventory.armor[5] then
						chestplatesquare.Image = bedwars["getIcon"](inventory.armor[5], true)
					else
						chestplatesquare.Image = ""
					end
					if inventory.armor[6] then
						bootssquare.Image = bedwars["getIcon"](inventory.armor[6], true)
					else
						bootssquare.Image = ""
					end
				end
			end
		end)
		return oldupdate(tab, targetsize)
	end
end)

GuiLibrary["RemoveObject"]("AimAssistOptionsButton")
runcode(function()
	local AimAssist = {["Enabled"] = false}
	local AimAssistSmoothness = {["Value"] = 1}
	local AimAssistTargetFrame = {["Players"] = {["Enabled"] = false}}
	local aimbegan
	local aimended
	local aimactive = false
	AimAssist = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton({
		["Name"] = "AimAssist",
		["Function"] = function(callback)
			if callback then
				aimbegan = uis.InputBegan:connect(function(input1)
					if uis:GetFocusedTextBox() == nil and input1.UserInputType == Enum.UserInputType.MouseButton1 then
						aimactive = true
					end
				end)
				
				aimended = uis.InputEnded:connect(function(input1)
					if input1.UserInputType == Enum.UserInputType.MouseButton1 then
						aimactive = false
					end
				end)
				
				BindToRenderStep("AimAssist", 1, function()
					if aimactive then
						local targettable = {}
						local targetsize = 0
						local plr = GetNearestHumanoidToPosition(AimAssistTargetFrame["Players"]["Enabled"], 30)
						if plr then
							targettable[plr.Name] = {
								["UserId"] = plr.UserId,
								["Health"] = (plr.Character and plr.Character.Humanoid and plr.Character.Humanoid.Health or 0),
								["MaxHealth"] = (plr.Character and plr.Character.Humanoid and plr.Character.Humanoid.MaxHealth or 0)
							}
							targetsize = targetsize + 1
						end
						if plr and getEquipped()["Type"] == "sword" and matchState ~= 0 and (AimAssistTargetFrame["Walls"]["Enabled"] and bedwars["SwordController"]:canSee({["instance"] = plr.Character, ["player"] = plr, ["getInstance"] = function() return plr.Character end}) or (not AimAssistTargetFrame["Walls"]["Enabled"])) then
							cam.CFrame = cam.CFrame:lerp(CFrame.new(cam.CFrame.p, plr.Character.HumanoidRootPart.Position), 1 / AimAssistSmoothness["Value"])
						end
						if getEquipped()["Type"] ~= "bow" then
							targetinfo.UpdateInfo(targettable, targetsize)
						end
					end
				end)
			else
				UnbindFromRenderStep("AimAssist")
				aimbegan:Disconnect()
				aimended:Disconnect()
				aimactive = false
			end
		end,
		["HoverText"] = "Helps your aim"
	})
	AimAssistTargetFrame = AimAssist.CreateTargetWindow({["Default3"] = true})
	AimAssistSmoothness = AimAssist.CreateSlider({
		["Name"] = "Smoothness",
		["Min"] = 1,
		["Max"] = 100, 
		["Function"] = function(val) end,
		["Default"] = 50
	})
end)

GuiLibrary["RemoveObject"]("AutoClickerOptionsButton")
local oldenable
local olddisable
local blockplacetable = {}
local blockplaceenabled = false
local autoclickercps = {["GetRandomValue"] = function() return 1 end}
local autoclicker = {["Enabled"] = false}
local autoclickertick = tick()
local autoclickerautoblock = {["Enabled"] = false}
local autoclickerblocks = {["Enabled"] = false}
local autoclickermousedown = false
local autoclickerconnection1
local autoclickerconnection2
local firstclick = false
autoclicker = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton({
	["Name"] = "AutoClicker",
	["Function"] = function(callback)
		if callback then
			oldenable = bedwars["BlockController2"]["enable"]
			olddisable = bedwars["BlockController2"]["disable"]
			bedwars["BlockController2"]["enable"] = function(Self, tab)
				blockplaceenabled = true
				blockplacetable = Self
				return oldenable(Self, tab)
			end
			bedwars["BlockController2"]["disable"] = function(Self)
				blockplaceenabled = false
				return olddisable(Self)
			end
			autoclickerconnection1 = uis.InputBegan:connect(function(input, gameProcessed)
				if gameProcessed and input.UserInputType == Enum.UserInputType.MouseButton1 then
					autoclickermousedown = true
					firstclick = true
				end
			end)
			autoclickerconnection2 = uis.InputEnded:connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					autoclickermousedown = false
				end
			end)
			BindToRenderStep("AutoClicker", 1, function() 
				if isAlive() and autoclickermousedown and autoclickertick <= tick() and bedwars["ClientStoreHandler"]:getState().App.shownApp <= 0 and GuiLibrary["MainGui"].ClickGui.Visible == false and matchState ~= 0 and firstclick == false then
					autoclickertick = tick() + (1 / autoclickercps["GetRandomValue"]())
					if getEquipped()["Type"] == "sword" then
						bedwars["SwordController"]["swingSwordAtMouse"](bedwars["SwordController"])
					end
					if autoclickerautoblock["Enabled"] and getItem("shield") then
						spawn(bedwars["raiseShield"])
					end
					if blockplaceenabled and autoclickerblocks["Enabled"] then
						local mouseinfo = blockplacetable.clientManager:getBlockSelector():getMouseInfo(0)
						if mouseinfo and getmetatable(bedwars["BlockController"])["isAllowedPlacement"](bedwars["BlockController"], lplr, blockplacetable.blockType, mouseinfo.placementPosition, 0) then
							bedwars["BlockController2"]["placeBlock"](blockplacetable, mouseinfo.placementPosition)
						end
					end
				else
					firstclick = false
				end
			end)
		else
			bedwars["BlockController2"]["enable"] = oldenable
			bedwars["BlockController2"]["disable"] = olddisable
			oldenable = nil
			olddisable = nil
			if autoclickerconnection1 then
				autoclickerconnection1:Disconnect()
			end
			if autoclickerconnection2 then
				autoclickerconnection2:Disconnect()
			end
			UnbindFromRenderStep("AutoClicker")
		end
	end,
	["HoverText"] = "Clicks for you"
})
autoclickercps = autoclicker.CreateTwoSlider({
	["Name"] = "CPS",
	["Min"] = 1,
	["Max"] = 20,
	["Function"] = function(val) end,
	["Default"] = 8,
	["Default2"] = 12
})
autoclickerautoblock = autoclicker.CreateToggle({
	["Name"] = "AutoBlock", 
	["Function"] = function() end, 
})
autoclickerblocks = autoclicker.CreateToggle({
	["Name"] = "Place Blocks", 
	["Function"] = function() end, 
	["Default"] = true
})

GuiLibrary["RemoveObject"]("ReachOptionsButton")
local oldclick
local reachtping = false
local Reach = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton({
	["Name"] = "Reach",
	["Function"] = function(callback)
		if callback then
			oldclick = bedwars["SwordController"]["swingSwordAtMouse"]
			bedwars["SwordController"]["swingSwordAtMouse"] = function(...)
				if isAlive() then
					local direction = mouse.UnitRay.Direction
					local raycastparameters = RaycastParams.new()
					raycastparameters.FilterDescendantsInstances = {lplr.Character, workspace.BedAlarmZones}
					raycastparameters.FilterType = Enum.RaycastFilterType.Blacklist
					local newray = workspace:Raycast(mouse.UnitRay.Origin, direction * 200, raycastparameters)
					if newray.Instance and (lplr.Character.PrimaryPart.Position - newray.Instance.Position).Magnitude <= 16 then
						local mag = (lplr.Character.PrimaryPart.Position - newray.Instance.Position).Magnitude
						local plr = bedwars["getEntityTable"].getEntity(newray.Instance)
						if mag > 14.4 and plr then
							if reachtping == false then
								local oldcframe = lplr.Character.HumanoidRootPart.CFrame
								reachtping = true
								lplr.Character.HumanoidRootPart.CFrame = oldcframe + (direction * (mag - 14))
								wait(0.05)
								oldclick(...)
								wait(0.1)
								lplr.Character.HumanoidRootPart.CFrame = oldcframe
								reachtping = false
								return nil
							end
						end
					end
				end
				return oldclick(...)
			end
		else
			bedwars["SwordController"]["swingSwordAtMouse"] = oldclick
			oldclick = nil
		end
	end, 
	["HoverText"] = "Works 2% of the time lol"
})
GuiLibrary["RemoveObject"]("MouseTPOptionsButton")
GuiLibrary["RemoveObject"]("PhaseOptionsButton")

local oldpos = Vector3.new(0, 0, 0)
local oldpos2 = Vector3.new(0, 0, 0)
local Spider = {["Enabled"] = false}

local function getScaffold(vec, diagonaltoggle)
	local realvec = Vector3.new(math.floor((vec.X / 3) + 0.5) * 3, math.floor((vec.Y / 3) + 0.5) * 3, math.floor((vec.Z / 3) + 0.5) * 3) 
	local newpos = (oldpos - realvec)
	local returedpos = realvec
	if isAlive() then
		local angle = math.deg(math.atan2(-lplr.Character.Humanoid.MoveDirection.X, -lplr.Character.Humanoid.MoveDirection.Z))
		local goingdiagonal = (angle >= 130 and angle <= 150) or (angle <= -35 and angle >= -50) or (angle >= 35 and angle <= 50) or (angle <= -130 and angle >= -150)
		if goingdiagonal and ((newpos.X == 0 and newpos.Z ~= 0) or (newpos.X ~= 0 and newpos.Z == 0)) and diagonaltoggle then
			return oldpos
		end
	end
    return realvec
end


local slowdownspeed = false
local speed = {["Enabled"] = false}
runcode(function()
	local nocheck = false
	local phaseconnection
	local phasedelay = tick()
	local phasedelay2 = tick()
	local phase = {["Enabled"] = false}
	local checktable = {}

	for i,v in pairs(workspace:GetChildren()) do
		if v:IsA("Folder") and v.Name:find("Map") == nil then
			table.insert(checktable, v)
		end
	end

	local function isPointInMapOccupied(p)
		local region = Region3.new(p - Vector3.new(1, 1, 1), p + Vector3.new(1, 1, 1))
		local possible = workspace:FindPartsInRegion3WithIgnoreList(region, {lplr.Character, unpack(checktable)})
	--	for i,v in pairs(possible) do
	--		print(v:GetFullName())
	--	end
		return (#possible == 0)
	end

	phase = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
		["Name"] = "Phase",
		["Function"] = function(callback)
			if callback then
				BindToRenderStep("Phase", 1, function()
					if isAlive() then
						local pos = lplr.Character.HumanoidRootPart.CFrame.p - Vector3.new(0, 1, 0)
						local pos2 = lplr.Character.HumanoidRootPart.CFrame.p + Vector3.new(0, 1, 0)
						local pos3 = lplr.Character.Head.CFrame.p
						local bird = (lplr.Character:GetAttribute("Shield_DODO_BIRD") and lplr.Character:GetAttribute("Shield_DODO_BIRD") > 0)
						local raycastparameters = RaycastParams.new()
						raycastparameters.FilterDescendantsInstances = {workspace.Map.Blocks, workspace.SpectatorPlatform}
						raycastparameters.FilterType = Enum.RaycastFilterType.Whitelist
						local newray = workspace:Raycast(pos3, lplr.Character.Humanoid.MoveDirection, raycastparameters)
						if phasedelay <= tick() then
							slowdownspeed = false
							nocheck = false
						end
						if newray and phasedelay <= tick() and phasedelay2 <= tick() and (not bird) and GuiLibrary["ObjectsThatCanBeSaved"]["SpiderOptionsButton"]["Api"]["Enabled"] == false then
						--	print((newray.Instance.Position.Y - lplr.Character.HumanoidRootPart.CFrame.p.Y))
							if isPointInMapOccupied(getScaffold(pos, false) + (newray.Normal * -6)) and isPointInMapOccupied(getScaffold(pos2, false) + (newray.Normal * -6)) then
								phasedelay = tick() + 0.075
								phasedelay2 = tick() + 0.3
								nocheck = true
								lplr.Character.HumanoidRootPart.CFrame = lplr.Character.HumanoidRootPart.CFrame + (newray.Normal * -2.5)
							end
						end
					end
				end)
				phaseconnection = game:GetService("RunService").Stepped:connect(function()
					if isAlive() then
						for i,v in pairs(lplr.Character:GetDescendants()) do
							if v:IsA("BasePart") then
								if nocheck then
									v.CanCollide = false
								elseif nocheck == false and v.Name == "HumanoidRootPart" then
									v.CanCollide = true
								end
							end
						end
					end
				end)
				if Spider["Enabled"] then
					phase["ToggleButton"](false)
					createwarning("Phase", "Disable Spider to use this feature", 4)
				end
			else
				UnbindFromRenderStep("Phase")
				if phaseconnection then
					phaseconnection:Disconnect()
				end
			end
		end,
		["HoverText"] = "Lets you phase/clip through walls. (works 60% of the time)"
	})
end)

runcode(function()
	local velohorizontal = {["Value"] = 100}
	local velovertical = {["Value"] = 100}
	local oldhori = bedwars["KnockbackTable"]["kbDirectionStrength"]
	local oldvert = bedwars["KnockbackTable"]["kbUpwardStrength"]
	local oldvelo
	local Velocity = {["Enabled"] = false}
	Velocity = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton({
		["Name"] = "Velocity",
		["Function"] = function(callback)
			if callback then
				oldvelo = bedwars["KnockbackTable2"]["applyKnockback"]
				bedwars["KnockbackTable2"]["applyKnockback"] = function(...)
					if velohorizontal["Value"] == 0 and Velocity["Enabled"] then
						return nil
					end
					return oldvelo(...)
				end
				bedwars["KnockbackTable"]["kbDirectionStrength"] = oldhori * (velohorizontal["Value"] / 100)
				bedwars["KnockbackTable"]["kbUpwardStrength"] = oldvert * (velovertical["Value"] / 100)
			else
				bedwars["KnockbackTable2"]["applyKnockback"] = oldvelo
				oldvelo = nil
				bedwars["KnockbackTable"]["kbDirectionStrength"] = oldhori
				bedwars["KnockbackTable"]["kbUpwardStrength"] = oldvert
			end
		end,
		["HoverText"] = "Reduces knockback taken"
	})
	velohorizontal = Velocity.CreateSlider({
		["Name"] = "Horizontal",
		["Min"] = 0,
		["Max"] = 100,
		["Function"] = function(val) 
			if Velocity["Enabled"] then
				bedwars["KnockbackTable"]["kbDirectionStrength"] = oldhori * (val / 100) 
			end
		end,
		["Default"] = 0
	})
	velovertical = Velocity.CreateSlider({
		["Name"] = "Vertical",
		["Min"] = 0,
		["Max"] = 100,
		["Function"] = function(val) 
			if Velocity["Enabled"] then
				bedwars["KnockbackTable"]["kbUpwardStrength"] = oldvert * (val / 100) 
			end
		end,
		["Default"] = 0
	})
end)

runcode(function()
	local oldclick
	local oldattackspeeds = {}
	local noclickdelay = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton({
		["Name"] = "NoClickDelay",
		["Function"] = function(callback)
			if callback then
				for i2,v2 in pairs(bedwars["ItemTable"]) do
					if type(v2) == "table" and rawget(v2, "sword") then
						oldattackspeeds[i2] = v2["sword"]["attackSpeed"]
						v2["sword"]["attackSpeed"] = 0.000000001
					end
				end
				oldclick = bedwars["SwordController"]["isClickingTooFast"]
				bedwars["SwordController"]["isClickingTooFast"] = function() return false end
			else
				for i2,v2 in pairs(bedwars["ItemTable"]) do
					if type(v2) == "table" and rawget(v2, "sword") and oldattackspeeds[i2] then
						v2["sword"]["attackSpeed"] = oldattackspeeds[i2]
					end
				end
				bedwars["SwordController"]["isClickingTooFast"] = oldclick
				oldclick = nil
				oldattackspeeds = {}
			end
		end, 
		["HoverText"] = "Removes Click Delay"
	})
end)

runcode(function()
	local Sprint = {["Enabled"] = false}
	Sprint = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton({
		["Name"] = "Sprint",
		["Function"] = function()
			spawn(function()
				repeat
					wait()
					if bedwars["sprintTable"].sprinting == false then
						getmetatable(bedwars["sprintTable"])["startSprinting"](bedwars["sprintTable"])
					end
				until Sprint["Enabled"] == false
			end)
		end,
		["HoverText"] = "Sets your sprinting to true"
	})
end)

GuiLibrary["RemoveObject"]("BlinkOptionsButton")
runcode(function()
	local Blink = {["Enabled"] = false}
	Blink = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
		["Name"] = "Blink",
		["Function"] = function(callback) 
			if callback then
				if GuiLibrary["ObjectsThatCanBeSaved"]["Blatant modeToggle"]["Api"]["Enabled"] then
					settings():GetService("NetworkSettings").IncomingReplicationLag = 99999
				else
					Blink["ToggleButton"](false)
				end
			else
				if GuiLibrary["ObjectsThatCanBeSaved"]["Blatant modeToggle"]["Api"]["Enabled"] then
					settings():GetService("NetworkSettings").IncomingReplicationLag = 0
				end
			end
		end,
		["HoverText"] = "Chokes all incoming packets (blatant mode required)\nPlease do not turn this on if you do not know what you are doing."
	})
end)

runcode(function()
	local function projvischeck(launchpos, targetpos)
		local direction = Ray.new(launchpos, (targetpos + Vector3.new(0, 0, 0) - launchpos).unit).Unit.Direction
		local raycastparameters = RaycastParams.new()
		raycastparameters.FilterDescendantsInstances = {lplr.Character, workspace.BedAlarmZones, workspace.ProjectileTargeting, workspace.Camera, workspace.BedwarsSounds}
		raycastparameters.FilterType = Enum.RaycastFilterType.Blacklist
		local newray = workspace:Raycast(launchpos, direction * 10000, raycastparameters)
		if newray and newray.Instance then
			local plr = bedwars["getEntityTable"].getEntity(newray.Instance)
			if plr then return true end
		end
		return false
	end

	local aimfov = {["Value"] = 1}	
	local aimvischeck = {["Enabled"] = false}
	local tar = nil
	local shoothook
	local aimbotping
	local velodelay = tick()
	local velooldpos = Vector3.new(0, 0, 0)
	local projtable = {
		["arrow"] = true,
		["crossbow_arrow"] = true,
		["tactical_crossbow_arrow"] = true
	}
	local ProjectileAimbot = {["Enabled"] = false}
	ProjectileAimbot = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
		["Name"] = "BowAimbot",
		["Function"] = function(callback) 
			if callback then
				spawn(function()
					repeat
						wait(1)
						aimbotping = tonumber(game:GetService("Stats"):FindFirstChild("PerformanceStats").Ping:GetValue())
						aimbotping = math.floor(aimbotping)
					until ProjectileAimbot["Enabled"] == false
				end)
				shoothook = bedwars["BowTable"]["calculateImportantLaunchValues"]
				bedwars["BowTable"]["calculateImportantLaunchValues"] = function(bowtable, projmeta, worldmeta, ...)
					local plr = GetNearestHumanoidToMouse(true, aimfov["Value"], false)
					if plr then
						tar = plr.Character.HumanoidRootPart
						if aimvischeck["Enabled"] then
							local launchPosition = bowtable:getLaunchPosition()
							if launchPosition then
								local realLaunchPosition = launchPosition + Vector3.new(0, 2, 0)
								if not projvischeck(realLaunchPosition, (tar.CFrame.p + Vector3.new(0, 2, 0))) then
									tar = nil
								end
							else
								tar = nil
							end
						end
					else
						tar = nil
					end
					if tar and projtable[projmeta.projectile] then
							local launchPosition = bowtable:getLaunchPosition()
							if not launchPosition then
								return nil
							end
							local realLaunchPosition = launchPosition + Vector3.new(0, 2, 0)
							local proj = projmeta:getProjectileMeta();
							if p26 then
								local v58 = proj.predictionLifetimeSec;
							else
								v58 = proj.lifetimeSec;
							end;
							local v59 = v58;
							if v59 == nil then
								v59 = 3;
							end;
							local v60 = proj.launchVelocity;
							if v60 == nil then
								v60 = 100;
							end;
							local projGravity = proj.gravitationalAcceleration;
							if projGravity == nil then
								projGravity = 196.2;
							end;
							local multi = (10 / v60) + 0.0005
							if projmeta.projectile == "arrow" then
								multi = multi + 0.002
							end
							local velocalc = (multi / 6) + (0.01 / aimbotping)
							local lookvec = (plr.Character.HumanoidRootPart.Velocity.X == 0 and Vector3.new(0, 0, 0) or Vector3.new(plr.Character.HumanoidRootPart.CFrame.lookVector.X * plr.Character.Humanoid.WalkSpeed, plr.Character.Humanoid.Jump and 3 or 0, plr.Character.HumanoidRootPart.CFrame.lookVector.Y * plr.Character.Humanoid.WalkSpeed))
							local realTargetPosition = (tar.Position + Vector3.new(0, 2, 0)) + (lookvec * ((realLaunchPosition - tar.Position).magnitude * velocalc))
							local v65 = Ray.new(realLaunchPosition, (realTargetPosition + Vector3.new(0, (realLaunchPosition - realTargetPosition).magnitude * multi, 0) - realLaunchPosition).unit)
							return {
								initialVelocity = (realLaunchPosition + (v65.Unit.Direction).Unit * ((Vector3.new(0, 0, 0) - realLaunchPosition).Magnitude) - realLaunchPosition).Unit * (v60 * projmeta.velocityMultiplier), 
								positionFrom = realLaunchPosition, 
								deltaT = v59, 
								gravitationalAcceleration = projGravity * projmeta.gravityMultiplier
							};
					else
						return shoothook(bowtable, projmeta, worldmeta, ...)
					end
				end
			else
				bedwars["BowTable"]["calculateImportantLaunchValues"] = shoothook
				tar = nil 
				shoothook = nil
			end
		end,
		["HoverText"] = "Auto Aims bow at closest player."
	})
	aimfov = ProjectileAimbot.CreateSlider({
		["Name"] = "FOV",
		["Min"] = 0,
		["Max"] = 1000,
		["Function"] = function(val) end, 
		["Default"] = 1000
	})
	aimvischeck = ProjectileAimbot.CreateToggle({
		["Name"] = "Visible Check",
		["Function"] = function() end,
		["Default"] = true
	})
end)

runcode(function()
	local antivoidpart
	local antivoidmethod = {["Value"] = "Dynamic"}
	local antitransparent = {["Enabled"] = false}
	local AntiVoid = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
		["Name"] = "AntiVoid", 
		["Function"] = function(callback)
			if callback then
				spawn(function()
					repeat wait() until antivoidypos ~= 0
					local specialpos = (workspace.MapCFrames:FindFirstChild("center") and workspace.MapCFrames.center.Value.p == Vector3.new(77, 11, 35))
					antivoidpart = Instance.new("Part")
					antivoidpart.CanCollide = false
					antivoidpart.Size = Vector3.new(10000, 1, 10000)
					antivoidpart.Anchored = true
					antivoidpart.Transparency = (antitransparent["Enabled"] and 1 or 0.5)
					antivoidpart.Position = Vector3.new(0, antivoidypos - 20, 0)
					antivoidpart.Touched:connect(function(touchedpart)
						if touchedpart.Parent == lplr.Character and isAlive() then
							lplr.Character.HumanoidRootPart.Velocity = Vector3.new(0, (antivoidmethod["Value"] == "Dynamic" and (math.abs(lplr.Character.HumanoidRootPart.Velocity.Y) + 2) or 100), 0)
						end
					end)
					antivoidpart.Parent = workspace
				end)
			else
				if antivoidpart then
					antivoidpart:Remove() 
				end
			end
		end, 
		["HoverText"] = "Gives you a chance to get on land (Bouncing Twice, abusing, or bad luck will lead to lagbacks)"
	})
	antivoidmethod = AntiVoid.CreateDropdown({
		["Name"] = "Mode",
		["List"] = {"Dynamic", "Set"},
		["Function"] = function() end
	})
	antitransparent = AntiVoid.CreateToggle({
		["Name"] = "Invisible",
		["Function"] = function(callback) 
			if antivoidpart then
				antivoidpart.Transparency = (callback and 1 or 0.5)
			end
		end,
		["Default"] = true
	})
end)

local function scaffoldBlock(newpos, customblock)
    bedwars["placeBlock"](newpos, customblock)
end

runcode(function()
	local oldenable2
	local olddisable2
	local oldhitblock
	local blockplacetable2 = {}
	local blockplaceenabled2 = false

	local AutoTool = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
		["Name"] = "AutoTool",
		["Function"] = function(callback)
			if callback then
				oldenable2 = bedwars["BlockHealthbar2"]["enable"]
				olddisable2 = bedwars["BlockHealthbar2"]["disable"]
				oldhitblock = bedwars["BlockHealthbar2"]["hitBlock"]
				bedwars["BlockHealthbar2"]["enable"] = function(Self, tab)
					blockplaceenabled2 = true
					blockplacetable2 = Self
					return oldenable2(Self, tab)
				end
				bedwars["BlockHealthbar2"]["disable"] = function(Self)
					blockplaceenabled2 = false
					return olddisable2(Self)
				end
				bedwars["BlockHealthbar2"]["hitBlock"] = function(...)
					if isAlive() and matchState ~= 0 and blockplaceenabled2 then
						local mouseinfo = blockplacetable2.clientManager:getBlockSelector():getMouseInfo(0)
						if mouseinfo and mouseinfo.target then
							switchToAndUseTool(mouseinfo.target.blockInstance, true)
						end
					end
					return oldhitblock(...)
				end
			else
				UnbindFromRenderStep("AutoTool")
				bedwars["BlockHealthbar2"]["enable"] = oldenable2
				bedwars["BlockHealthbar2"]["disable"] = olddisable2
				bedwars["BlockHealthbar2"]["hitBlock"] = oldhitblock
				oldenable2 = nil
				olddisable2 = nil
				oldhitblock = nil
			end
		end,
		["HoverText"] = "Automatically swaps your hand to the appropriate tool."
	})
end)

runcode(function()
	local BedNuker = {["Enabled"] = false}
	local bednukerdigpos = {["Value"] = "Right"}
	local bednukerrange = {["Value"] = 1}
	local bednukereffects = {["Enabled"] = false}
	BedNuker = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
		["Name"] = "BedNuker",
		["Function"] = function(callback)
			spawn(function()
				repeat
					wait()
					local tab = bedwars["BedTable"]
					for i = 1, #tab do
						local obj = tab[i]
						if isAlive() then
							if obj and obj:FindFirstChild("Covers") and obj.Covers.BrickColor ~= lplr.Team.TeamColor and obj.Parent ~= nil then
								if (lplr.Character.HumanoidRootPart.Position - obj.Position).magnitude <= bednukerrange["Value"] then
									bedwars["breakBlock"](obj.Position, bednukereffects["Enabled"], bednukerdigpos["Value"])
									wait(0.3)
								end
							end
						end
					end
				until BedNuker["Enabled"] == false
			end)
		end,
		["HoverText"] = "Automatically destroys beds around you."
	})
	bednukerdigpos = BedNuker.CreateDropdown({
		["Name"] = "Break Direction", 
		["List"] = normalsides,
		["Function"] = function(val) end
	})
	bednukerrange = BedNuker.CreateSlider({
		["Name"] = "Break range",
		["Min"] = 1, 
		["Max"] = 20, 
		["Function"] = function(val) end, 
		["Default"] = 20
	})
	bednukereffects = BedNuker.CreateToggle({
		["Name"] = "Show HealthBar & Effects",
		["Function"] = function(callback) 
			if not callback then
				bedwars["BlockHealthbar2"].healthbarMaid:DoCleaning()
			end
		 end,
		["Default"] = true
	})
end)

runcode(function()
	local BedProtector = {["Enabled"] = false}
	local bedprotector1stlayer = {
		Vector3.new(0, 3, 0),
		Vector3.new(0, 3, 3),
		Vector3.new(3, 0, 0),
		Vector3.new(3, 0, 3),
		Vector3.new(-3, 0, 0),
		Vector3.new(-3, 0, 3),
		Vector3.new(0, 0, 6),
		Vector3.new(0, 0, -3)
	}
	local bedprotector2ndlayer = {
		Vector3.new(0, 6, 0),
		Vector3.new(0, 6, 3),
		Vector3.new(0, 3, 6),
		Vector3.new(0, 3, -3),
		Vector3.new(0, 0, -6),
		Vector3.new(0, 0, 9),
		Vector3.new(3, 3, 0),
		Vector3.new(3, 3, 3),
		Vector3.new(3, 0, 6),
		Vector3.new(3, 0, -3),
		Vector3.new(6, 0, 3),
		Vector3.new(6, 0, 0),
		Vector3.new(-3, 3, 3),
		Vector3.new(-3, 3, 0),
		Vector3.new(-6, 0, 3),
		Vector3.new(-6, 0, 0),
		Vector3.new(-3, 0, 6),
		Vector3.new(-3, 0, -3),
	}

	local function getItemFromList(list)
		local selecteditem
		for i3,v3 in pairs(list) do
			local item = getItem(v3)
			if item then 
				selecteditem = item
				break
			end
		end
		return selecteditem
	end

	local function placelayer(layertab, obj, selecteditems)
		for i2,v2 in pairs(layertab) do
			local selecteditem = getItemFromList(selecteditems)
			if selecteditem then
				bedwars["placeBlock"](obj.Position + v2, selecteditem["itemType"])
			else
				return false
			end
		end
		return true
	end

	local bedprotectorrange = {["Value"] = 1}
	BedProtector = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
		["Name"] = "BedProtector",
		["Function"] = function(callback)
            if callback then
                spawn(function()
                    for i, obj in pairs(bedwars["BedTable"]) do
                        if isAlive() and obj and obj:FindFirstChild("Covers") and obj.Covers.BrickColor == lplr.Team.TeamColor and obj.Parent ~= nil then
                            if (lplr.Character.HumanoidRootPart.Position - obj.Position).magnitude <= bedprotectorrange["Value"] then
                                local firstlayerplaced = placelayer(bedprotector1stlayer, obj, {"obsidian", "stone_brick", "plank_oak", getwool()})
							    if firstlayerplaced then
									placelayer(bedprotector2ndlayer, obj, {getwool()})
							    end
                            end
                            break
                        end
                    end
                    BedProtector["ToggleButton"](false)
                end)
            end
		end,
		["HoverText"] = "Automatically places a bed defense (Toggle)"
	})
	bedprotectorrange = BedProtector.CreateSlider({
		["Name"] = "Place range",
		["Min"] = 1, 
		["Max"] = 20, 
		["Function"] = function(val) end, 
		["Default"] = 20
	})
end)

--[[runcode(function()
	local TrapPlayer = {["Enabled"] = false}

	local function getItemFromList(list)
		local selecteditem
		for i3,v3 in pairs(list) do
			local item = getItem(v3)
			if item then 
				selecteditem = item
				break
			end
		end
		return selecteditem
	end

	local function rotate(tab, cframe)
		for i,v in pairs(tab) do
			local radvec, radius = cframe:ToAxisAngle()
			radius = (radius * 57.2957795)
			radius = math.round(radius / 90) * 90
			if radvec == Vector3.new(0, -1, 0) and radius == 90 then
				radius = 270
			end
			local rot = CFrame.new() * CFrame.fromAxisAngle(Vector3.new(0, 1, 0), math.rad(radius))
			local newpos = CFrame.new(0, 0, 0) * rot * CFrame.new(v)
			tab[i] = Vector3.new(math.round(newpos.p.X), math.round(newpos.p.Y), math.round(newpos.p.Z))
		end
	end

	local function placelayer(layertab, obj, selecteditems, delaytoggle)
		for i2,v2 in pairs(layertab) do
			local selecteditem = getItemFromList(selecteditems)
			if selecteditem then
				spawn(function()
					bedwars["placeBlock"](obj + v2, selecteditem["itemType"])
				end)
				if delaytoggle then
					task.wait(0.01)
				end
			end
		end
	end

	local trapplayerrange = {["Value"] = 1}
	TrapPlayer = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
		["Name"] = "TrapPlayer",
		["Function"] = function(callback)
            if callback then
                spawn(function()
					local plr = GetNearestHumanoidToPosition(true, trapplayerrange["Value"])
					if plr then
						local movedir = plr.Character.HumanoidRootPart.Velocity ~= Vector3.new(0, 0, 0) and (plr.Character.HumanoidRootPart.CFrame.lookVector * 6) or Vector3.new(0, 0, 0)
						local pos = getScaffold((plr.Character.HumanoidRootPart.Position - Vector3.new(0, 2, 0)) + movedir)
						local positions = {
							[1] = Vector3.new(0, 0, -6),
							[2] = Vector3.new(0, 3, -6),
							[3] = Vector3.new(0, 6, -6),
							[4] = Vector3.new(3, 0, -6),
							[5] = Vector3.new(3, 3, -6),
							[6] = Vector3.new(3, 6, -6),
							[7] = Vector3.new(-3, 0, -6),
							[8] = Vector3.new(-3, 3, -6),
							[9] = Vector3.new(-3, 6, -6),
						}
						local positions2 = {
							[100] = Vector3.new(-6, 0, 0),
							[200] = Vector3.new(-6, 0, 3),
							[300] = Vector3.new(-6, 3, 3),
							[400] = Vector3.new(-6, 3, 0),
							[500] = Vector3.new(-6, 3, -3),
							[600] = Vector3.new(-6, 0, -3),
							[700] = Vector3.new(-6, 6, -3),
							[800] = Vector3.new(-6, 6, 0),
							[900] = Vector3.new(-6, 6, 3),
							[10] = Vector3.new(6, 0, 3),
							[11] = Vector3.new(6, 3, 3),
							[12] = Vector3.new(6, 3, 0),
							[13] = Vector3.new(6, 3, -3),
							[14] = Vector3.new(6, 0, -3),
							[15] = Vector3.new(6, 6, -3),
							[16] = Vector3.new(6, 6, 0),
							[17] = Vector3.new(6, 6, 3),
							[18] = Vector3.new(6, 0, 0),
							[22] = Vector3.new(-3, 3, -6),
							[23] = Vector3.new(-3, 0, -6),
							[24] = Vector3.new(-3, 6, -6),
							[28] = Vector3.new(3, 0, 6),
							[29] = Vector3.new(3, 3, 6),
							[30] = Vector3.new(0, 3, 6),
							[34] = Vector3.new(0, 6, 6),
							[35] = Vector3.new(3, 6, 6),
							[36] = Vector3.new(0, 0, 6),
							[37] = Vector3.new(3, 9, 3),
							[38] = Vector3.new(3, 9, 0),
							[39] = Vector3.new(0, 9, 0),
							[40] = Vector3.new(-3, 9, 0),
							[41] = Vector3.new(-3, 9, 3),
							[42] = Vector3.new(-3, 9, -3),
							[43] = Vector3.new(0, 9, -3),
							[44] = Vector3.new(3, 9, -3),
							[45] = Vector3.new(0, 9, 3),
							[1] = Vector3.new(3, -3, -3),
							[2] = Vector3.new(0, -3, -3),
							[3] = Vector3.new(-3, -3, -3),
							[4] = Vector3.new(-3, -3, 0),
							[5] = Vector3.new(0, -3, 0),
							[6] = Vector3.new(3, -3, 0),
							[7] = Vector3.new(3, -3, 3),
							[8] = Vector3.new(0, -3, 3),
							[9] = Vector3.new(-3, -3, 3)
						 }
						rotate(positions, plr.Character.HumanoidRootPart.CFrame)
						rotate(positions2, plr.Character.HumanoidRootPart.CFrame)
						placelayer(positions, pos, {getwool()})
						placelayer(positions2, pos, {getwool()}, true)
						if getItem("tnt") then
							bedwars["placeBlock"](pos, "tnt")
						end
					end
					TrapPlayer["ToggleButton"](false)
                end)
            end
		end,
		["HoverText"] = "works 1% of the time due to lag lol (Toggle)"
	})
	trapplayerrange = TrapPlayer.CreateSlider({
		["Name"] = "Place range",
		["Min"] = 1, 
		["Max"] = 20, 
		["Function"] = function(val) end, 
		["Default"] = 20
	})
end)]]

runcode(function()
	local LuckyBlockNuker = {["Enabled"] = false}
    local luckyconnection
    local luckyconnection2
    local luckyblocktable = {}
	local luckyblocknukerdigpos = {["Value"] = "Right"}
	local luckyblocknukerrange = {["Value"] = 1}
	local luckyblocknukereffects = {["Enabled"] = false}
	LuckyBlockNuker = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
		["Name"] = "LuckyBlockNuker",
		["Function"] = function(callback)
            if callback then
                for i,v in pairs(workspace:GetChildren()) do
                    if v.Name:find("lucky") then
                        table.insert(luckyblocktable, v)
                    end
                end
                luckyconnection = workspace.ChildAdded:connect(function(v)
                    if v.Name == "lucky_block" then
                        table.insert(luckyblocktable, v)
                    end
                end)
                luckyconnection2 = workspace.ChildRemoved:connect(function(v)
                    if v.Name == "lucky_block" then
                        table.remove(luckyblocktable, table.find(luckyblocktable, v))
                    end
                end)
                spawn(function()
                    repeat
                        wait()
                        local tab = luckyblocktable
                        for i = 1, #tab do
                            local obj = tab[i]
                            if isAlive() then
                                if obj and obj.Parent ~= nil then
                                    if (lplr.Character.HumanoidRootPart.Position - obj.Position).magnitude <= luckyblocknukerrange["Value"] then
                                        bedwars["breakBlock"](obj.Position, luckyblocknukereffects["Enabled"], luckyblocknukerdigpos["Value"], true)
                                        wait(0.3)
                                    end
                                end
                            end
                        end
                    until LuckyBlockNuker["Enabled"] == false
                end)
            else
             --   luckyconnection:Disconnect()
              --  luckyconnection2:Disconnect()
              --  luckyblocktable = {}
            end
		end,
		["HoverText"] = "Automatically destroys lucky blocks around you."
	})
	luckyblocknukerdigpos = LuckyBlockNuker.CreateDropdown({
		["Name"] = "Break Direction", 
		["List"] = normalsides,
		["Function"] = function(val) end
	})
	luckyblocknukerrange = LuckyBlockNuker.CreateSlider({
		["Name"] = "Break range",
		["Min"] = 1, 
		["Max"] = 20, 
		["Function"] = function(val) end, 
		["Default"] = 20
	})
	luckyblocknukereffects = LuckyBlockNuker.CreateToggle({
		["Name"] = "Show HealthBar & Effects",
		["Function"] = function(callback) 
			if not callback then
				bedwars["BlockHealthbar2"].healthbarMaid:DoCleaning()
			end
		 end,
		["Default"] = true
	})
end)

runcode(function()
	local swords = {
		["wood_sword"] = "stone_sword",
		["stone_sword"] = "iron_sword",
		["iron_sword"] = "diamond_sword",
		["diamond_sword"] = "emerald_sword"
	}
	local betterswords = {
		["stone_sword"] = 2,
		["iron_sword"] = 3,
		["diamond_sword"] = 4,
		["emerald_sword"] = 5,
	}


	local function checkallswords()
		local highestsword = 1
		local currentbuyablesword = nil
		for i, v in pairs(betterswords) do
			local NextSwordTable = bedwars["Shop"].getShopItem(i)
			local NextSwordCurrency = getItem(NextSwordTable["currency"])
			if NextSwordCurrency and NextSwordCurrency["amount"] >= NextSwordTable["price"] and highestsword < v then
				highestsword =  v
				currentbuyablesword = i
			end
		end
		return currentbuyablesword
	end

	local AutoBuy = {["Enabled"] = false}
	local autobuydelay = tick()
	local AutoBuyArmor = {["Enabled"] = false}
	local AutoBuySword = {["Enabled"] = false}
	local AutoBuyUpgrades = {["Enabled"] = false}
	local AutoBuyGen = {["Enabled"] = false}
	local AutoBuyProt = {["Enabled"] = false}
	local AutoBuySharp = {["Enabled"] = false}
	local AutoBuyBreakSpeed = {["Enabled"] = false}
	local AutoBuyAlarm = {["Enabled"] = false}
	local AutoBuyGui = {["Enabled"] = false}
	local buyingthing = false
	local shoothook
	local bedwarsshopnpcs = {}
	spawn(function()
		repeat wait() until matchState ~= 0
		for i,v in pairs(workspace:GetChildren()) do
			if v:FindFirstChild("BedwarsItemShop") or v:FindFirstChild("BedwarsTeamUpgrader") then
				table.insert(bedwarsshopnpcs, {["Position"] = v.Position, ["TeamUpgradeNPC"] = v:FindFirstChild("BedwarsTeamUpgrader")})
			end
		end
	end)

	local function nearNPC()
		if isAlive() then
			for i, v in pairs(bedwarsshopnpcs) do
				if (lplr.Character.HumanoidRootPart.Position - v.Position).magnitude <= 10 then
					return true, v.TeamUpgradeNPC
				end
			end
		end
		return false
	end

	local function buyitem(itemtab, sucfunc)
		if getItem(itemtab.itemType) == nil then
			if itemtab.itemType == "emerald_sword" then
				local sword, swordnum = getSword()
				if sword.itemType ~= "emerald_sword" then
					local swordSlot = swordnum
					sword["tool"]:Remove()
				end
			end
			bedwars["ClientHandler"]:Get("BedwarsPurchaseItem"):CallServerAsync({
				shopItem = itemtab
			}):andThen(function(p11)
				sucfunc(p11)
				if p11 then
					bedwars["SoundManager"]:playSound(12)
					bedwars["ClientStoreHandler"]:dispatch({
						type = "BedwarsAddItemPurchased", 
						itemType = itemtab.itemType
					});
					if itemtab.nextTier then
						local ShopItems = bedwars["Shop"].ShopItems;
						local function isNextTier(p12)
							return p12.itemType == NextArmorTable.nextTier;
						end;
						local itemToSelect = nil;
						for itemnum, item in ipairs(ShopItems) do
							if isNextTier(item, itemnum - 1, ShopItems) == true then
								itemToSelect = item;
								break;
							end;
						end;
						bedwars["SetSelectedShopItem"](itemToSelect);
						return;
					elseif itemtab.tiered or itemtab.lockAfterPurchase then

					end
				end
			end)
		end
	end

	local justboughtarmor = ""
	local justboughtsword = ""

	lplr.CharacterAdded:connect(function()
		local ExecuteInventory = bedwars["getInventory"](lplr)
		justboughtarmor = (getSword() and getSword()["itemType"] or "")
		justboughtsword = (ExecuteInventory.armor[5] and ExecuteInventory.armor[5].itemType or "")
	end)

	local BuyCheck = function() end
	BuyCheck = function(upgradesshopnpc)
		if AutoBuy["Enabled"] and matchState == 1 then
			local ExecuteInventory = bedwars["getInventory"](lplr)
			local NextArmor = ExecuteInventory.armor[5] and bedwars["Shop"].getShopItem(ExecuteInventory.armor[5].itemType) and bedwars["Shop"].getShopItem(ExecuteInventory.armor[5].itemType)["nextTier"] or (getArmor() == nil and "leather_chestplate" or nil)
			local NextSword = getSword()
			local GeneratorUpgrade = bedwars["Shop"].getUpgrade(bedwars["Shop"]["TeamUpgrades"], "generator")
			local ProtectionUpgrade = bedwars["Shop"].getUpgrade(bedwars["Shop"]["TeamUpgrades"], "armor")
			local SharpnessUpgrade = bedwars["Shop"].getUpgrade(bedwars["Shop"]["TeamUpgrades"], "damage")
			local BreakSpeedUpgrade = bedwars["Shop"].getUpgrade(bedwars["Shop"]["TeamUpgrades"], "break")
			local AlarmUpgrade = bedwars["Shop"].getUpgrade(bedwars["Shop"]["TeamUpgrades"], "alarm")
			if not upgradesshopnpc then
				if AutoBuySword["Enabled"] and NextSword and kit ~= "barbarian" and (AutoBuyGui["Enabled"] and (bedwars["ClientStoreHandler"]:getState().App.shownApp == 5 or bedwars["ClientStoreHandler"]:getState().App.shownApp == 4) or (not AutoBuyGui["Enabled"])) then
					local buyablesword = checkallswords()
					if buyablesword and NextSword and betterswords[buyablesword] > (NextSword.itemType ~= "wood_sword" and betterswords[NextSword.itemType] or 1) then
						local NextSwordTable = bedwars["Shop"].getShopItem(buyablesword)
						local NextSwordCurrency = getItem(NextSwordTable["currency"])
						if NextSwordCurrency and NextSwordCurrency["amount"] >= NextSwordTable["price"] then
							if justboughtsword ~= buyablesword and getItem("rageblade") == nil then
								local oldboughtsword = justboughtsword
								justboughtsword = buyablesword
								buyitem(NextSwordTable, function(suc)
									if suc then
										NextSword = swords[NextSwordTable["itemType"]]
									else
										justboughtsword = oldboughtsword
									end
								end)
							end
						end
					end
				end
				if AutoBuyArmor["Enabled"] and NextArmor and (AutoBuyGui["Enabled"] and bedwars["ClientStoreHandler"]:getState().App.shownApp == 5 or (not AutoBuyGui["Enabled"])) then
					local NextArmorTable = bedwars["Shop"].getShopItem(NextArmor)
					local NextArmorCurrency = getItem(NextArmorTable["currency"])
					if NextArmorCurrency and NextArmorCurrency["amount"] >= NextArmorTable["price"] then
						if justboughtarmor ~= NextArmor then
							local oldboughtarmor = justboughtarmor
							justboughtarmor = NextArmor
							buyitem(NextArmorTable, function(suc)
								if suc then
									NextArmor = NextArmorTable["nextTier"]
								else
									justboughtarmor = oldboughtarmor
								end
							end)
						end
					end
				end
			else
				if AutoBuyUpgrades["Enabled"] and (AutoBuyGui["Enabled"] and bedwars["ClientStoreHandler"]:getState().App.shownApp == 4 or (not AutoBuyGui["Enabled"])) then
					local CurrentUpgrades = bedwars["ClientStoreHandler"]:getState()["Bedwars"]["teamUpgrades"]
					local GenNewTier = GeneratorUpgrade["tiers"][CurrentUpgrades["generator"] and CurrentUpgrades["generator"] + 2 or 1]
					local ProtNewTier = ProtectionUpgrade["tiers"][CurrentUpgrades["armor"] and CurrentUpgrades["armor"] + 2 or 1]
					local SharpNewTier = SharpnessUpgrade["tiers"][CurrentUpgrades["damage"] and CurrentUpgrades["damage"] + 2 or 1]
					local BreakSpeedNewTier = BreakSpeedUpgrade["tiers"][CurrentUpgrades["break"] and CurrentUpgrades["break"] + 2 or 1]
					local AlarmNewTier = AlarmUpgrade["tiers"][CurrentUpgrades["alarm"] and CurrentUpgrades["alarm"] + 2 or 1]
					if GenNewTier and AutoBuyGen["Enabled"] then
						local GenCurrency = getItem(GenNewTier["currency"])
						if GenCurrency and GenCurrency["amount"] >= GenNewTier["price"] then
							bedwars["ClientHandler"]:Get("BedwarsPurchaseTeamUpgrade"):CallServerAsync({
								upgradeId = "generator", 
								tier = CurrentUpgrades["generator"] and CurrentUpgrades["generator"] + 1 or 0
							}):andThen(function()
								bedwars["SoundManager"]:playSound(11)
							end)
						end
					end
					if ProtNewTier and AutoBuyProt["Enabled"] then
						local ProtCurrency = getItem(ProtNewTier["currency"])
						if ProtCurrency and ProtCurrency["amount"] >= ProtNewTier["price"] then
							bedwars["ClientHandler"]:Get("BedwarsPurchaseTeamUpgrade"):CallServerAsync({
								upgradeId = "armor", 
								tier = CurrentUpgrades["armor"] and CurrentUpgrades["armor"] + 1 or 0
							}):andThen(function()
								bedwars["SoundManager"]:playSound(11)
							end)
						end
					end
					if SharpNewTier and AutoBuySharp["Enabled"] then
						local SharpCurrency = getItem(SharpNewTier["currency"])
						if SharpCurrency and SharpCurrency["amount"] >= SharpNewTier["price"] then
							bedwars["ClientHandler"]:Get("BedwarsPurchaseTeamUpgrade"):CallServerAsync({
								upgradeId = "damage", 
								tier = CurrentUpgrades["damage"] and CurrentUpgrades["damage"] + 1 or 0
							}):andThen(function()
								bedwars["SoundManager"]:playSound(11)
							end)
						end
					end
					if BreakSpeedNewTier and AutoBuyBreakSpeed["Enabled"] then
						local BreakSpeedCurrency = getItem(BreakSpeedNewTier["currency"])
						if BreakSpeedCurrency and BreakSpeedCurrency["amount"] >= BreakSpeedNewTier["price"] then
							bedwars["ClientHandler"]:Get("BedwarsPurchaseTeamUpgrade"):CallServerAsync({
								upgradeId = "break", 
								tier = CurrentUpgrades["break"] and CurrentUpgrades["break"] + 1 or 0
							}):andThen(function()
								bedwars["SoundManager"]:playSound(11)
							end)
						end
					end
					if AlarmNewTier and AutoBuyAlarm["Enabled"] then
						local AlarmCurrency = getItem(AlarmNewTier["currency"])
						if AlarmCurrency and AlarmCurrency["amount"] >= AlarmNewTier["price"] then
							bedwars["ClientHandler"]:Get("BedwarsPurchaseTeamUpgrade"):CallServerAsync({
								upgradeId = "alarm", 
								tier = CurrentUpgrades["alarm"] and CurrentUpgrades["alarm"] + 1 or 0
							}):andThen(function()
								bedwars["SoundManager"]:playSound(11)
							end)
						end
					end
				end
			end
		end
	end
	AutoBuy = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
		["Name"] = "AutoBuy", 
		["Function"] = function(callback)
			if callback then 
				buyingthing = false 
				BindToRenderStep("AutoBuy", 1, function()
					local found, npctype = nearNPC()
					if found and autobuydelay <= tick() then
						BuyCheck(npctype)
						autobuydelay = tick() + 0.2
					end
				end)
			else
				UnbindFromRenderStep("AutoBuy")
			end
		end,
		["HoverText"] = "Automatically Buys Swords, Armor, and Team Upgrades\nwhen you walk near the NPC"
	})
	AutoBuyArmor = AutoBuy.CreateToggle({
		["Name"] = "Buy Armor",
		["Function"] = function() end, 
		["Default"] = true
	})
	AutoBuySword = AutoBuy.CreateToggle({
		["Name"] = "Buy Sword",
		["Function"] = function() end, 
		["Default"] = true
	})
	AutoBuyUpgrades = AutoBuy.CreateToggle({
		["Name"] = "Buy Team Upgrades",
		["Function"] = function(callback) 
			if AutoBuyUpgrades["Object"] then
				AutoBuyUpgrades["Object"].ToggleArrow.Visible = callback
			end
			if AutoBuyGen["Object"] then
				AutoBuyGen["Object"].Visible = callback
			end
			if AutoBuyProt["Object"] then
				AutoBuyProt["Object"].Visible = callback
			end
			if AutoBuySharp["Object"] then
				AutoBuySharp["Object"].Visible = callback
			end
			if AutoBuyBreakSpeed["Object"] then
				AutoBuyBreakSpeed["Object"].Visible = callback
			end
			if AutoBuyAlarm["Object"] then
				AutoBuyAlarm["Object"].Visible = callback
			end
		end, 
		["Default"] = true
	})
	AutoBuyGen = AutoBuy.CreateToggle({
		["Name"] = "Buy Team Generator",
		["Function"] = function() end, 
	})
	AutoBuyProt = AutoBuy.CreateToggle({
		["Name"] = "Buy Protection",
		["Function"] = function() end, 
		["Default"] = true
	})
	AutoBuySharp = AutoBuy.CreateToggle({
		["Name"] = "Buy Sharpness",
		["Function"] = function() end, 
		["Default"] = true
	})
	AutoBuyBreakSpeed = AutoBuy.CreateToggle({
		["Name"] = "Buy Break Speed",
		["Function"] = function() end, 
	})
	AutoBuyAlarm = AutoBuy.CreateToggle({
		["Name"] = "Buy Alarm",
		["Function"] = function() end, 
	})
	AutoBuyGen["Object"].BackgroundTransparency = 0
	AutoBuyGen["Object"].BorderSizePixel = 0
	AutoBuyGen["Object"].BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	AutoBuyGen["Object"].Visible = AutoBuyUpgrades["Enabled"]
	AutoBuyProt["Object"].BackgroundTransparency = 0
	AutoBuyProt["Object"].BorderSizePixel = 0
	AutoBuyProt["Object"].BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	AutoBuyProt["Object"].Visible = AutoBuyUpgrades["Enabled"]
	AutoBuySharp["Object"].BackgroundTransparency = 0
	AutoBuySharp["Object"].BorderSizePixel = 0
	AutoBuySharp["Object"].BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	AutoBuySharp["Object"].Visible = AutoBuyUpgrades["Enabled"]
	AutoBuyBreakSpeed["Object"].BackgroundTransparency = 0
	AutoBuyBreakSpeed["Object"].BorderSizePixel = 0
	AutoBuyBreakSpeed["Object"].BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	AutoBuyBreakSpeed["Object"].Visible = AutoBuyUpgrades["Enabled"]
	AutoBuyAlarm["Object"].BackgroundTransparency = 0
	AutoBuyAlarm["Object"].BorderSizePixel = 0
	AutoBuyAlarm["Object"].BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	AutoBuyAlarm["Object"].Visible = AutoBuyUpgrades["Enabled"]
	AutoBuyGui = AutoBuy.CreateToggle({
		["Name"] = "Shop GUI Check",
		["Function"] = function() end, 
	})
end)

runcode(function()
	local Schematica = {["Enabled"] = false}
	local SchematicaBox = {["Value"] = ""}
	local SchematicaTransparency = {["Value"] = 30}
	local positions = {}
	local tempfolder
	local tempgui
	local aroundpos = {
		[1] = Vector3.new(0, 3, 0),
		[2] = Vector3.new(-3, 3, 0),
		[3] = Vector3.new(-3, -0, 0),
		[4] = Vector3.new(-3, -3, 0),
		[5] = Vector3.new(0, -3, 0),
		[6] = Vector3.new(3, -3, 0),
		[7] = Vector3.new(3, -0, 0),
		[8] = Vector3.new(3, 3, 0),
		[9] = Vector3.new(0, 3, -3),
		[10] = Vector3.new(-3, 3, -3),
		[11] = Vector3.new(-3, -0, -3),
		[12] = Vector3.new(-3, -3, -3),
		[13] = Vector3.new(0, -3, -3),
		[14] = Vector3.new(3, -3, -3),
		[15] = Vector3.new(3, -0, -3),
		[16] = Vector3.new(3, 3, -3),
		[17] = Vector3.new(0, 3, 3),
		[18] = Vector3.new(-3, 3, 3),
		[19] = Vector3.new(-3, -0, 3),
		[20] = Vector3.new(-3, -3, 3),
		[21] = Vector3.new(0, -3, 3),
		[22] = Vector3.new(3, -3, 3),
		[23] = Vector3.new(3, -0, 3),
		[24] = Vector3.new(3, 3, 3),
		[25] = Vector3.new(0, -0, 3),
		[26] = Vector3.new(0, -0, -3)
	}

	local function isNearBlock(pos)
		for i,v in pairs(aroundpos) do
			if getblock(pos + v) then
				return true
			end
		end
		return false
	end

	local function gethighlightboxatpos(pos)
		if tempfolder then
			for i,v in pairs(tempfolder:GetChildren()) do
				if v.Position == pos then
					return v 
				end
			end
		end
		return nil
	end

	local function removeduplicates(tab)
		local actualpositions = {}
		for i,v in pairs(tab) do
			if table.find(actualpositions, Vector3.new(v.X, v.Y, v.Z)) == nil then
				table.insert(actualpositions, Vector3.new(v.X, v.Y, v.Z))
			else
				table.remove(tab, i)
			end
			if v["blockType"] == "start_block" then
				table.remove(tab, i)
			end
		end
	end

	local function rotate(tab)
		for i,v in pairs(tab) do
			local radvec, radius = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame:ToAxisAngle()
			radius = (radius * 57.2957795)
			radius = math.round(radius / 90) * 90
			if radvec == Vector3.new(0, -1, 0) and radius == 90 then
				radius = 270
			end
			local rot = CFrame.new() * CFrame.fromAxisAngle(Vector3.new(0, 1, 0), math.rad(radius))
			local newpos = CFrame.new(0, 0, 0) * rot * CFrame.new(Vector3.new(v.X, v.Y, v.Z))
			v.X = math.round(newpos.p.X)
			v.Y = math.round(newpos.p.Y)
			v.Z = math.round(newpos.p.Z)
		end
	end

	local function getmaterials(tab)
		local materials = {}
		for i,v in pairs(tab) do
			materials[v["blockType"]] = (materials[v["blockType"]] and materials[v["blockType"]] + 1 or 1)
		end
		return materials
	end

	Schematica = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
		["Name"] = "Schematica",
		["Function"] = function(callback)
			if callback then
				local mouseinfo = bedwars["BlockEngine"]:getBlockSelector():getMouseInfo(0)
				if mouseinfo and isfile(SchematicaBox["Value"]) then
					tempfolder = Instance.new("Folder")
					tempfolder.Parent = workspace
					local newpos = mouseinfo.placementPosition * 3
					positions = game:GetService("HttpService"):JSONDecode(readfile(SchematicaBox["Value"]))
					rotate(positions)
					removeduplicates(positions)
					bedwars["placeBlock"](newpos)
					for i2,v2 in pairs(positions) do
						local texturetxt = bedwars["getItemMetadata"]((v2["blockType"] == "wool_white" and getwool() or v2["blockType"]))["block"]["greedyMesh"]["textures"][1]
						local newerpos = (newpos + Vector3.new(v2.X, v2.Y, v2.Z))
						local block = Instance.new("Part")
						block.Position = newerpos
						block.Size = Vector3.new(3, 3, 3)
						block.CanCollide = false
						block.Transparency = (SchematicaTransparency["Value"] == 10 and 0 or 1)
						block.Anchored = true
						block.Parent = tempfolder
						for i3,v3 in pairs(Enum.NormalId:GetEnumItems()) do
							local texture = Instance.new("Texture")
							texture.Face = v3
							texture.Texture = texturetxt
							texture.Name = tostring(v3)
							texture.Transparency = (SchematicaTransparency["Value"] == 10 and 0 or (1 / SchematicaTransparency["Value"]))
							texture.Parent = block
						end
					end
					spawn(function()
						repeat
							wait()
							for i,v in pairs(positions) do
								local newerpos = (newpos + Vector3.new(v.X, v.Y, v.Z))
								if isAlive() and (lplr.Character.HumanoidRootPart.Position - newerpos).magnitude <= 30 and isNearBlock(newerpos) and getmetatable(bedwars["BlockController"])["isAllowedPlacement"](bedwars["BlockController"], lplr, getwool(), newerpos / 3, 0) then
									bedwars["placeBlock"](newerpos, (v["blockType"] == "wool_white" and getwool() or v["blockType"]))
									table.remove(positions, i)
									if gethighlightboxatpos(newerpos) then
										gethighlightboxatpos(newerpos):Remove()
									end
								end
							end
						until #positions == 0 or Schematica["Enabled"] == false
						if Schematica["Enabled"] then 
							Schematica["ToggleButton"](false)
							createwarning("Schematica", "Finished Placing Blocks", 4)
						end
					end)
				end
			else
				positions = {}
				if tempfolder then
					tempfolder:Remove()
				end
			end
		end,
		["HoverText"] = "Automatically places structure at mouse position."
	})
	SchematicaBox = Schematica.CreateTextBox({
		["Name"] = "File",
		["TempText"] = "File (location in workspace)",
		["FocusLost"] = function(enter) 
				local suc, res = pcall(function() return game:GetService("HttpService"):JSONDecode(readfile(SchematicaBox["Value"])) end)
				if tempgui then
					tempgui:Remove()
				end
				if suc then
					removeduplicates(res)
					tempgui = Instance.new("Frame")
					tempgui.Name = "SchematicListOfBlocks"
					tempgui.BackgroundTransparency = 1
					tempgui.LayoutOrder = 9999
					tempgui.Parent = SchematicaBox["Object"].Parent
					local uilistlayoutschmatica = Instance.new("UIListLayout")
					uilistlayoutschmatica.Parent = tempgui
					uilistlayoutschmatica:GetPropertyChangedSignal("AbsoluteContentSize"):connect(function()
						tempgui.Size = UDim2.new(0, 220, 0, uilistlayoutschmatica.AbsoluteContentSize.Y)
					end)
					for i4,v4 in pairs(getmaterials(res)) do
						local testframe = Instance.new("Frame")
						testframe.Size = UDim2.new(0, 220, 0, 40)
						testframe.BackgroundTransparency = 1
						testframe.Parent = tempgui
						local testimage = Instance.new("ImageLabel")
						testimage.Size = UDim2.new(0, 40, 0, 40)
						testimage.Position = UDim2.new(0, 3, 0, 0)
						testimage.BackgroundTransparency = 1
						testimage.Image = bedwars["getIcon"]({["itemType"] = i4}, true)
						testimage.Parent = testframe
						local testtext = Instance.new("TextLabel")
						testtext.Size = UDim2.new(1, -50, 0, 40)
						testtext.Position = UDim2.new(0, 50, 0, 0)
						testtext.TextSize = 20
						testtext.Text = v4
						testtext.Font = Enum.Font.SourceSans
						testtext.TextXAlignment = Enum.TextXAlignment.Left
						testtext.TextColor3 = Color3.new(1, 1, 1)
						testtext.BackgroundTransparency = 1
						testtext.Parent = testframe
					end
				end
		end
	})
	SchematicaTransparency = Schematica.CreateSlider({
		["Name"] = "Transparency",
		["Min"] = 0,
		["Max"] = 10,
		["Default"] = 7,
		["Function"] = function()
			if tempfolder then
				for i2,v2 in pairs(tempfolder:GetChildren()) do
					v2.Transparency = (SchematicaTransparency["Value"] == 10 and 0 or 1)
					for i3,v3 in pairs(v2:GetChildren()) do
						v3.Transparency = (SchematicaTransparency["Value"] == 10 and 0 or (1 / SchematicaTransparency["Value"]))
					end
				end
			end
		end
	})
end)


runcode(function()
	local autoheal = {["Enabled"] = false}
	local autohealval = {["Value"] = 100}
	local autohealdelay = tick()
	local autohealbound = false
	autoheal = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
		["Name"] = "AutoEat",
		["Function"] = function(callback)
			if callback then
					autohealbound = true
					BindToRenderStep("AutoHeal", 1, function()
						if isAlive() and lplr.Character.Humanoid.Health <= autohealval["Value"] and autohealdelay <= tick() then
							autohealdelay = tick() + 0.5
							if getItem("apple") then
								bedwars["ClientHandler"]:Get(bedwars["EatRemote"]):CallServer({
									["item"] = getItem("apple")["tool"]
								})
							end
						end
					end)
			else
				if autohealbound then
					autohealbound = false
					UnbindFromRenderStep("AutoHeal")
				end
			end
		end,
		["HoverText"] = "Automatically heals you (Baker Only)"
	})
	autohealval = autoheal.CreateSlider({
		["Name"] = "Health",
		["Min"] = 1,
		["Max"] = 99,
		["Default"] = 70,
		["Function"] = function() end
	})
end)

--[[runcode(function()
	local targetstrafenum = 0
	local targetstrafenum2 = 0
	local goup = true
	local noplr = true
	local targetstrafe = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
		["Name"] = "TargetStrafe",
		["Function"] = function(callback)
			if callback then
				BindToRenderStep("TargetStrafe", 1, function(delta)
					if isAlive() then
						local plr = GetNearestHumanoidToPosition(true, 10)
						if plr then
							if noplr then
								local pos, num = plr.Character.HumanoidRootPart.CFrame:ToAxisAngle()
								targetstrafenum = -(num * 57.2957795)
								noplr = false
							end
							local newpos = (CFrame.new(plr.Character.HumanoidRootPart.CFrame.p) * CFrame.Angles(0, math.rad(targetstrafenum), 0) * CFrame.new(0, 0, 8)) + Vector3.new(0, targetstrafenum2, 0)
							if (lplr.Character.HumanoidRootPart.Position - newpos.p).magnitude >= 4 then
								lplr.Character.HumanoidRootPart.CFrame = lplr.Character.HumanoidRootPart.CFrame:lerp(newpos, 2.2 * delta)
							else
								lplr.Character.HumanoidRootPart.CFrame = newpos
							end
							lplr.Character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
							targetstrafenum = targetstrafenum + 1.5
							if targetstrafenum >= 360 then
								targetstrafenum = 0
							end
							if goup then
								targetstrafenum2 = targetstrafenum2 + 0.1
								if targetstrafenum2 >= 4 then
									goup = false
								end
							else
								targetstrafenum2 = targetstrafenum2 - 0.1
								if targetstrafenum2 <= 0 then
									goup = true
								end
							end
						else
							noplr = true
						end
					end
				end)
			else
				UnbindFromRenderStep("TargetStrafe")
			end
		end,
		["HoverText"] = "Automatically moves around attacking players"
	})
end)
]]
GuiLibrary["RemoveObject"]("LongJumpOptionsButton")
GuiLibrary["RemoveObject"]("HighJumpOptionsButton")
runcode(function()
	local HighJumpBoost = {["Value"] = 1}
	local HighJumpDelay = {["Value"] = 20}
	local HighJumpTick = tick()
	local highjumpbound = true
	local HighJump = {["Enabled"] = false}
	HighJump = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
		["Name"] = "HighJump",
		["Function"] = function(callback)
			if callback then
				if HighJumpTick <= tick() and isAlive() and (lplr.Character.Humanoid:GetState() == Enum.HumanoidStateType.Running or lplr.Character.Humanoid:GetState() == Enum.HumanoidStateType.RunningNoPhysics) then
					HighJumpTick = tick() + (HighJumpDelay["Value"] / 10)
					lplr.Character.HumanoidRootPart.Velocity = Vector3.new(0, HighJumpBoost["Value"], 0)
				else
					createwarning("LongJump", "Wait "..(math.floor((HighJumpTick - tick()) * 10) / 10).." before retoggling.", 1)
				end
				HighJump["ToggleButton"](false)
			else

			end
		end, 
		["HoverText"] = "Lets you jump higher (Spamming has a chance to lagback)"
	})
	HighJumpBoost = HighJump.CreateSlider({
		["Name"] = "Boost",
		["Min"] = 1,
		["Max"] = 150,
		["Function"] = function(val) end,
		["Default"] = 100
	})
	HighJumpDelay = HighJump.CreateSlider({
		["Name"] = "Delay",
		["Min"] = 0,
		["Max"] = 50,
		["Function"] = function(val) end, 
		["Default"] = 20
	})
end)
GuiLibrary["RemoveObject"]("KillauraOptionsButton")

local spiderparts = {}

local function createpart(pos, ysize, part)
	local truss = Instance.new("TrussPart")
	truss.Size = Vector3.new(2, ysize, 2)
	truss.Name = "spiderman"
	truss.Position = (part.Position - (part.Size / 2)) + Vector3.new(math.clamp(pos.X, 0,  part.Size.X - 1), math.clamp(pos.Y, 0, part.Size.Y), math.clamp(pos.Z, 0, part.Size.Z - 1))
	truss.Transparency = 1
	truss.Anchored = true
	truss.Parent = part
	table.insert(spiderparts, truss)
	return truss
end

runcode(function()
	local spiderconnection
	local cando = true
	Spider = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
		["Name"] = "Spider",
		["Function"] = function(callback)
			if callback then
				if cando and #spiderparts <= 0 then
					cando = false
					spiderconnection = workspace.Map.Blocks.ChildAdded:connect(function(v)
						for i3 = 1, v.Size.Z + 1 do
							for i2 = 1, v.Size.X + 1 do
								createpart(Vector3.new(i2, v.Size.Y / 2, i3), v.Size.Y, v)
							end
						end
					end)
					spawn(function()
						repeat wait() until matchState ~= 0
						local spidermessage = Instance.new("TextLabel")
						spidermessage.Size = UDim2.new(1, 0, 0, 36)
						spidermessage.Text = "Parts Processed : 0"
						spidermessage.BackgroundTransparency = 1
						spidermessage.TextStrokeTransparency = 0
						spidermessage.TextSize = 30
						spidermessage.Font = Enum.Font.SourceSans
						spidermessage.TextColor3 = Color3.new(1, 1, 1)
						spidermessage.Position = UDim2.new(0, 0, 0, -36)
						spidermessage.Parent = GuiLibrary["MainGui"]
						local tempblocks = workspace.Map.Blocks:GetChildren()
						for i,v in pairs(tempblocks) do
							spidermessage.Text = "Parts Processed : "..tostring(i).."/"..tostring(#tempblocks)
							if i % 25 == 0 then
								wait(0.04)
							end
							for i3 = 1, v.Size.Z + 1 do
								for i2 = 1, v.Size.X + 1 do
									createpart(Vector3.new(i2, v.Size.Y / 2, i3), v.Size.Y, v)
								end
							end
						end
						spidermessage:Remove()
						cando = true
					end)
				end
			else
				if cando then
					cando = false
					if spiderconnection then
						spiderconnection:Disconnect()
					end
					spawn(function()
						local spidermessage = Instance.new("TextLabel")
						spidermessage.Size = UDim2.new(1, 0, 0, 36)
						spidermessage.Text = "Spider Parts Removed : 0"
						spidermessage.BackgroundTransparency = 1
						spidermessage.TextStrokeTransparency = 0
						spidermessage.TextSize = 30
						spidermessage.Font = Enum.Font.SourceSans
						spidermessage.TextColor3 = Color3.new(1, 1, 1)
						spidermessage.Position = UDim2.new(0, 0, 0, -36)
						spidermessage.Parent = GuiLibrary["MainGui"]
						for i,v in pairs(spiderparts) do
							spidermessage.Text = "Spider Parts Removed : "..tostring(i).."/"..tostring(#spiderparts)
							if i % 1000 == 0 then
								wait(0.04)
							end
							v:Remove()
						end
						cando = true
						spidermessage:Remove()
						spiderparts = {}
					end)
				end
			end
		end,
		["HoverText"] = "Lets you climb up walls after the lagspike."
	})
end)

local killaurabox = Instance.new("BoxHandleAdornment")
killaurabox.Transparency = 0.5
killaurabox.Color3 = Color3.new(1, 0, 0)
killaurabox.Adornee = nil
killaurabox.AlwaysOnTop = true
killaurabox.ZIndex = 11
killaurabox.Parent = GuiLibrary["MainGui"]
local killauratargetframe = {["Players"] = {["Enabled"] = false}}
local killaurarealremote = bedwars["ClientHandler"]:Get(bedwars["AttackRemote"])["instance"]
local killauramethod = {["Value"] = "Normal"}
local killauraanimmethod = {["Value"] = "Normal"}
local killauraaps = {["GetRandomValue"] = function() return 1 end}
local killaurarange = {["Value"] = 14}
local killauraangle = {["Value"] = 360}
local killauratargets = {["Value"] = 10}
local killauramouse = {["Enabled"] = false}
local killauracframe = {["Enabled"] = false}
local killauraautoblock = {["Enabled"] = false}
local killauragui = {["Enabled"] = false}
local killauratarget = {["Enabled"] = false}
local killaurasound = {["Enabled"] = false}
local killauraswing = {["Enabled"] = false}
local killaurahandcheck = {["Enabled"] = false}
local killaurabaguette = {["Enabled"] = false}
local killauraanimation = {["Enabled"] = false}
local Killaura = {["Enabled"] = false}
local killauradelay = 0
local Killauranear = false
local killauraplaying = false
local oldplay = function() end
local oldsound = function() end

local function hashvec(vec)
	return {
		["hash"] = bedwars["AttackHashFunction"](bedwars["AttackHashText"], bedwars["prepareHashing"](vec)), 
		["value"] = vec
	}
end

Killaura = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
	["Name"] = "Killaura",
	["Function"] = function(callback)
		if callback then
			oldplay = bedwars["ViewmodelController"]["playAnimation"]
			oldsound = bedwars["SoundManager"]["playSound"]
			bedwars["SoundManager"]["playSound"] = function(tab, soundid, ...)
				if (soundid == 13 or soundid == 14) and Killaura["Enabled"] and killaurasound["Enabled"] and killauranear then
					return nil
				end
				return oldsound(tab, soundid, ...)
			end
			bedwars["ViewmodelController"]["playAnimation"] = function(Self, id, ...)
				if id == 5 and killauranear and killauraswing["Enabled"] and isAlive() then
					return nil
				end
				if id == 5 and killauranear and killauraanimation["Enabled"] and isAlive() then
					pcall(function()
						if origC0 == nil then
							origC0 = cam.Viewmodel.RightHand.RightWrist.C0
						end
						if killauraplaying == false then
							killauraplaying = true
							if killauraanimmethod["Value"] == "Normal" or killauraanimmethod["Value"] == "Slow" then
								game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new((killauraanimmethod["Value"] == "Normal" and 0.1 or 0.2)), {C0 = origC0 * CFrame.new(0.7, -1, 0.6) * CFrame.Angles(-math.rad(45), math.rad(55), -math.rad(70))}):Play()
								wait((killauraanimmethod["Value"] == "Normal" and 0.05 or 0.1))
								game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new((killauraanimmethod["Value"] == "Normal" and 0.1 or 0.2)), {C0 = origC0 * CFrame.new(0.7, -1, 0.6) * CFrame.Angles(-math.rad(45), math.rad(105), -math.rad(70))}):Play()
								wait((killauraanimmethod["Value"] == "Normal" and 0.05 or 0.1))
							elseif killauraanimmethod["Value"] == "Vertical Spin" then
								game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new(0.15, Enum.EasingStyle.Linear), {C0 = origC0 * CFrame.Angles(-math.rad(90), math.rad(0), -math.rad(0))}):Play()
								wait(0.1)
								game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new(0.15, Enum.EasingStyle.Linear), {C0 = origC0 * CFrame.Angles(-math.rad(180), math.rad(0), -math.rad(0))}):Play()
								wait(0.1)
								game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new(0.15, Enum.EasingStyle.Linear), {C0 = origC0 * CFrame.Angles(-math.rad(240), math.rad(0), -math.rad(0))}):Play()
								wait(0.1)
								game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new(0.15, Enum.EasingStyle.Linear), {C0 = origC0 * CFrame.Angles(-math.rad(359), math.rad(0), -math.rad(0))}):Play()
								wait(0.1)
							elseif killauraanimmethod["Value"] == "Horizontal Spin" then
								game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new(0.15, Enum.EasingStyle.Linear), {C0 = origC0 * CFrame.Angles(-math.rad(45), math.rad(90), -math.rad(70))}):Play()
								wait(0.1)
								game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new(0.15, Enum.EasingStyle.Linear), {C0 = origC0 * CFrame.Angles(-math.rad(45), math.rad(180), -math.rad(70))}):Play()
								wait(0.1)
								game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new(0.15, Enum.EasingStyle.Linear), {C0 = origC0 * CFrame.Angles(-math.rad(45), math.rad(240), -math.rad(70))}):Play()
								wait(0.1)
								game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new(0.15, Enum.EasingStyle.Linear), {C0 = origC0 * CFrame.Angles(-math.rad(45), math.rad(359), -math.rad(70))}):Play()
								wait(0.1)
							end
							killauraplaying = false
						end
					end)
					return nil
				end
				return oldplay(Self, id, ...)
			end
			BindToRenderStep("Killaura", 1, function() 
				local targettable = {}
				local targetsize = 0
				if (killauradelay <= tick()) and matchState ~= 0 then
					local plrs = GetAllNearestHumanoidToPosition(killauratargetframe["Players"]["Enabled"], killaurarange["Value"] + 0.4, killauratargets["Value"])
					if #plrs <= 0 then
						killauranear = false
						if killaurabox.Adornee ~= nil then
							killaurabox.Adornee = nil
						end
						pcall(function()
							if origC0 == nil then
								origC0 = cam.Viewmodel.RightHand.RightWrist.C0
							end
							if cam.Viewmodel.RightHand.RightWrist.C0 ~= origC0 then
								game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new(0.1), {C0 = origC0}):Play()
							end
						end)
					end
					if #plrs > 0 then
						killauradelay = tick() + (1 / killauraaps["GetRandomValue"]())
					end
					for i,plr in pairs(plrs) do
						if isAlive() and (killauratargetframe["NPCs"]["Enabled"] == false or killauratargetframe["NPCs"]["Enabled"]) and (killaurahandcheck["Enabled"] and getEquipped()["Type"] == "sword" or (not killaurahandcheck["Enabled"])) and (killauratargetframe["Walls"]["Enabled"] and bedwars["SwordController"]:canSee({["instance"] = plr.Character, ["player"] = plr, ["getInstance"] = function() return plr.Character end}) or (not killauratargetframe["Walls"]["Enabled"])) and (killauramouse["Enabled"] and uis:IsMouseButtonPressed(0) or (not killauramouse["Enabled"])) and (killauragui["Enabled"] and (bedwars["ClientStoreHandler"]:getState().App.shownApp <= 0 and GuiLibrary["MainGui"].ClickGui.Visible == false) or (not killauragui["Enabled"])) then
							if plr.Character.PrimaryPart and lplr.Character.PrimaryPart then
								killauranear = true
								if killauraautoblock["Enabled"] and getItem("shield") then
									spawn(bedwars["raiseShield"])
								end
								if killauracframe["Enabled"] then
									lplr.Character:SetPrimaryPartCFrame(CFrame.new(lplr.Character.PrimaryPart.Position, Vector3.new(plr.Character:FindFirstChild("HumanoidRootPart").Position.X, lplr.Character.PrimaryPart.Position.Y, plr.Character:FindFirstChild("HumanoidRootPart").Position.Z)))
								end
								if killauratarget["Enabled"] then
									local ori, size = plr.Character:GetBoundingBox()
									killaurabox.Adornee = (killauratarget["Enabled"] and plr.Character or nil)
									killaurabox.Size = size + Vector3.new(.01, .01, .01)
								end
								targettable[plr.Name] = {
									["UserId"] = plr.UserId,
									["Health"] = (plr.Character and plr.Character.Humanoid and plr.Character.Humanoid.Health or 0),
									["MaxHealth"] = (plr.Character and plr.Character.Humanoid and plr.Character.Humanoid.MaxHealth or 0)
								}
								targetsize = targetsize + 1
								spawn(function()
									if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then 
										if killauramethod["Value"] == "Normal" then
											if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then 
												getmetatable(bedwars["SwordController"])["attackEntity"]({["lastAttack"] = tick() - 1, ["getHandItem"] = function() if killaurabaguette["Enabled"] and getBaguette() then return getBaguette() else return getSword() end end}, {["instance"] = plr.Character, ["player"] = plr, ["getInstance"] = function() return plr.Character end}, Ray.new(cam.CFrame.p, plr.Character.HumanoidRootPart.Position).Unit.Direction)
											end
											if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then 
												getmetatable(bedwars["SwordController"])["attackEntity"]({["lastAttack"] = tick() - 1, ["getHandItem"] = function() if killaurabaguette["Enabled"] and getBaguette() then return getBaguette() else return getSword() end end}, {["instance"] = plr.Character, ["player"] = plr, ["getInstance"] = function() return plr.Character end}, Ray.new(cam.CFrame.p, plr.Character.HumanoidRootPart.Position).Unit.Direction)
											end
										else
											bedwars["ViewmodelController"]:playAnimation(5)
											bedwars["SoundManager"]:playSound(math.random(13, 14))
										--	if table.find(playerwhitelist, sha(tostring(plr.UserId))) == nil then
												killaurarealremote:InvokeServer({
													["weapon"] = killaurabaguette["Enabled"] and getBaguette() and getBaguette()["tool"] or getSword()["tool"],
													["entityInstance"] = plr.Character,
													["validate"] = {
														["raycast"] = {
															["cameraPosition"] = hashvec(cam.CFrame.p), 
															["cursorDirection"] = hashvec(Ray.new(cam.CFrame.p, plr.Character.HumanoidRootPart.Position).Unit.Direction)
														},
														["targetPosition"] = hashvec(plr.Character.HumanoidRootPart.Position),
														["selfPosition"] = hashvec(lplr.Character.HumanoidRootPart.Position)
													}
												})
											--end
											local plrentity = bedwars["getEntityTable"].getLocalPlayerEntity()
											if plrentity ~= nil and isAlive() then
												plrentity:playAnimation(0)
											end
										end
									end
								end)
							end
						else
							killauranear = false
							if killaurabox.Adornee ~= nil then
								killaurabox.Adornee = nil
							end
							pcall(function()
								if origC0 == nil then
									origC0 = cam.Viewmodel.RightHand.RightWrist.C0
								end
								if cam.Viewmodel.RightHand.RightWrist.C0 ~= origC0 then
									game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new(0.1), {C0 = origC0}):Play()
								end
							end)
						end
					end
					if getEquipped()["Type"] ~= "bow" then
						targetinfo.UpdateInfo(targettable, targetsize)
					end
				end
			end)
		else
			killauranear = false
			bedwars["ViewmodelController"]["playAnimation"] = oldplay
			bedwars["SoundManager"]["playSound"] = oldsound
			oldplay = nil
			pcall(function()
				if origC0 == nil then
					origC0 = cam.Viewmodel.RightHand.RightWrist.C0
				end
				if cam.Viewmodel.RightHand.RightWrist.C0 ~= origC0 then
					game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new(0.1), {C0 = origC0}):Play()
				end
			end)
			UnbindFromRenderStep("Killaura") 
		end
	end,
	["HoverBox"] = "Attack players around you\nwithout aiming at them.\nAutoBlock requires Inferno Shielder"
})
killauratargetframe = Killaura.CreateTargetWindow({})
killauraaps = Killaura.CreateTwoSlider({
	["Name"] = "Attacks per Second",
	["Min"] = 1,
	["Max"] = 10,
	["Function"] = function(val) end, 
	["Default"] = 8,
	["Default2"] = 10
})
killaurarange = Killaura.CreateSlider({
	["Name"] = "Attack range",
	["Min"] = 1,
	["Max"] = 14,
	["Function"] = function(val) end, 
	["Default"] = 14
})
killauraangle = Killaura.CreateSlider({
	["Name"] = "Max angle",
	["Min"] = 1,
	["Max"] = 360,
	["Function"] = function(val) end,
	["Default"] = 360
})
killauratargets = Killaura.CreateSlider({
	["Name"] = "Max targets",
	["Min"] = 1,
	["Max"] = 10,
	["Function"] = function(val) end,
	["Default"] = 10
})
killauramethod = Killaura.CreateDropdown({
	["Name"] = "Mode", 
	["List"] = {"Direct", "Normal"},
	["Function"] = function(val) end
})
killauraanimmethod = Killaura.CreateDropdown({
	["Name"] = "Animation", 
	["List"] = {"Normal", "Slow", "Vertical Spin", "Horizontal Spin"},
	["Function"] = function(val) end
})
killauraautoblock = Killaura.CreateToggle({
	["Name"] = "AutoBlock",
	["Function"] = function() end,
	["Default"] = true
})
killauramouse = Killaura.CreateToggle({
	["Name"] = "Require mouse down",
	["Function"] = function() end,
	["Default"] = false
})
killauragui = Killaura.CreateToggle({
	["Name"] = "GUI Check",
	["Function"] = function() end,
})
killauratarget = Killaura.CreateToggle({
	["Name"] = "Show target",
	["Function"] = function() end,
})
killauracframe = Killaura.CreateToggle({
	["Name"] = "Face target",
	["Function"] = function() end,
})
killaurasound = Killaura.CreateToggle({
	["Name"] = "No Swing Sound",
	["Function"] = function() end,
})
killauraswing = Killaura.CreateToggle({
	["Name"] = "No Swing",
	["Function"] = function() end,
})
killaurahandcheck = Killaura.CreateToggle({
	["Name"] = "Limit to items",
	["Function"] = function() end,
})
killaurabaguette = Killaura.CreateToggle({
	["Name"] = "Baguette Aura",
	["Function"] = function() end,
})
killauraanimation = Killaura.CreateToggle({
	["Name"] = "Custom Animation",
	["Function"] = function() end,
})

local FastPickupRange = {["Value"] = 1}
local FastPickup = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
	["Name"] = "FastPickup", 
	["Function"] = function(callback)
		if callback then
			BindToRenderStep("FastPickup", 1, function()
				local itemdrops = collectionservice:GetTagged("ItemDrop")
				if isAlive() then
					for i,v in pairs(itemdrops) do
						if (lplr.Character.HumanoidRootPart.Position - v.Position).magnitude <= FastPickupRange["Value"] and (v:GetAttribute("ClientDropTime") and tick() - v:GetAttribute("ClientDropTime") > 2 or v:GetAttribute("ClientDropTime") == nil) then
							bedwars["ClientHandler"]:Get(bedwars["PickupRemote"]):CallServerAsync({
								itemDrop = v
							}):andThen(function(p14)
								if p14 then
									bedwars["SoundManager"]:playSound(8)
								end
							end)
						end
					end
				end
			end)
		else
			UnbindFromRenderStep("FastPickup")
		end
	end
})
FastPickupRange = FastPickup.CreateSlider({
	["Name"] = "Range",
	["Min"] = 1,
	["Max"] = 10, 
	["Function"] = function() end,
	["Default"] = 10
})

runcode(function()
	local FastDrop = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
		["Name"] = "FastDrop",
		["Function"] = function(callback)
			if callback then
				BindToRenderStep("FastDrop", 1, function()
					if isAlive() and (not bedwars["ClientStoreHandler"]:getState().Inventory.opened) and (uis:IsKeyDown(Enum.KeyCode.Q) or uis:IsKeyDown(Enum.KeyCode.Backspace)) and uis:GetFocusedTextBox() == nil then
						bedwars["DropItem"]()
					end
				end)
			else
				UnbindFromRenderStep("FastDrop")
			end
		end,
		["HoverText"] = "Drops items fast when you hold Q"
	})
end)

local AutoToxic = {["Enabled"] = false}
local AutoToxicGG = {["Enabled"] = false}
local AutoToxicWin = {["Enabled"] = false}
local AutoToxicDeath = {["Enabled"] = false}
local AutoToxicRespond = {["Enabled"] = false}
local AutoToxicFinalKill = {["Enabled"] = false}
local AutoToxicWinStreak = {["Enabled"] = false}
local AutoToxicAd = {["Enabled"] = false}
local AutoToxicPhrases = {["RefreshValues"] = function() end, ["ObjectList"] = {}}
local AutoToxicPhrases2 = {["RefreshValues"] = function() end, ["ObjectList"] = {}}
local AutoToxicPhrases3 = {["RefreshValues"] = function() end, ["ObjectList"] = {}}
local AutoToxicPhrases4 = {["RefreshValues"] = function() end, ["ObjectList"] = {}}
local AutoToxicOldWin = bedwars["VictoryScreen"].render
local victorysaid = false
local responddelay = false
local lastsaid = ""
local lastsaid2 = ""
local ignoredplayers = {}
bedwars["VictoryScreen"].render = function(winstuff)
    local myTeam = bedwars["ClientStoreHandler"]:getState().Game.myTeam
    if myTeam and myTeam.id == winstuff.props.WinningTeamId and victorysaid == false then
		victorysaid = true
		if AutoToxic["Enabled"] then
			if AutoToxicGG["Enabled"] then
				game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("gg", "All")
			end
			if AutoToxicWin["Enabled"] then
				game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(#AutoToxicPhrases["ObjectList"] > 0 and AutoToxicPhrases["ObjectList"][math.random(1, #AutoToxicPhrases["ObjectList"])] or "EZ L TRASH KIDS"..(AutoToxicAd["Enabled"] and " : Sponsored by VXPE V4 :)" or ""), "All")
			end
		end
    end
    return AutoToxicOldWin(winstuff)
end

chatconnection = game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.OnMessageDoneFiltering.OnClientEvent:connect(function(tab, channel)
	local plr = players[tab["FromSpeaker"]]
	if (tab["Message"]:lower():find("hack") or tab["Message"]:lower():find("exploit")) and plr ~= lplr and table.find(ignoredplayers, plr.UserId) == nil and AutoToxic["Enabled"] and AutoToxicRespond["Enabled"] then
		local custommsg = #AutoToxicPhrases4["ObjectList"] > 0 and AutoToxicPhrases4["ObjectList"][math.random(1, #AutoToxicPhrases4["ObjectList"])]
		if custommsg == lastsaid2 then
			custommsg = #AutoToxicPhrases4["ObjectList"] > 0 and AutoToxicPhrases4["ObjectList"][math.random(1, #AutoToxicPhrases4["ObjectList"])]
		else
			lastsaid2 = custommsg
		end
		if custommsg then
			custommsg = custommsg:gsub("<name>", (plr.DisplayName or plr.Name))
		end
		local msg = custommsg or "waaaa waaaa "..(plr.DisplayName or plr.Name)
		game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(msg, "All")
		table.insert(ignoredplayers, plr.UserId)
	end
end)

local AutoArmor = {["Enabled"] = false}
AutoArmor = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
	["Name"] = "AutoArmor",
	["Function"] = function(callback)
		if callback then
			AutoArmor["ToggleButton"](false)
			if localentity == nil then
				localentity = bedwars["getEntityTable"]["getLocalPlayerEntity"]()
			end
			if isAlive() and getArmor() then
				local inv = bedwars["getInventory"](lplr)
				for i5, v5 in pairs(inv["items"]) do
					if v5["itemType"]:match("helmet") then
						localentity.equipArmorItem(localentity, v5["tool"], 0)
						bedwars["ClientStoreHandler"]:dispatch({
							type = "InventorySetArmorItem", 
							item = v5, 
							armorSlot = 0
						})
						bedwars["ClientStoreHandler"]:getState().Inventory.observedInventory.inventory.items[i5 + 1] = nil
					elseif v5["itemType"]:match("chestplate") then
						localentity.equipArmorItem(localentity, v5["tool"], 1)
						bedwars["ClientStoreHandler"]:dispatch({
							type = "InventorySetArmorItem", 
							item = v5, 
							armorSlot = 1
						})
						bedwars["ClientStoreHandler"]:getState().Inventory.observedInventory.inventory.items[i5 + 1] = nil
					elseif v5["itemType"]:match("boots") then
						localentity.equipArmorItem(localentity, v5["tool"], 2)
						bedwars["ClientStoreHandler"]:dispatch({
							type = "InventorySetArmorItem", 
							item = v5, 
							armorSlot = 2
						})
						bedwars["ClientStoreHandler"]:getState().Inventory.observedInventory.inventory.items[i5 + 1] = nil
					end
				end
			end
		end
	end, 
	["HoverText"] = "Automatically equips armor on toggle."
})

local AutoLeave = {["Enabled"] = false}
local AutoLeaveDelay = {["Value"] = 1}
local autoleaveconnection

bedwars["ClientHandler"]:OnEvent("MatchEndEvent", function(p2)
	if AutoLeave["Enabled"] then
		wait(AutoLeaveDelay["Value"] / 10)
		bedwars["ClientHandler"]:Get("TeleportToLobby"):SendToServer()
	end
end)
AutoLeave = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
	["Name"] = "AutoLeave", 
	["Function"] = function(callback)
		if callback then
			autoleaveconnection = players.PlayerAdded:connect(function(plr)
				spawn(function()
					if plr:IsInGroup(5774246) and plr:GetRankInGroup(5774246) >= 100 then
						bedwars["ClientHandler"]:Get("TeleportToLobby"):SendToServer()
					end
				end)
			end)
			spawn(function()
				for i, plr in pairs(players:GetChildren()) do
					if plr:IsInGroup(5774246) and plr:GetRankInGroup(5774246) >= 100 then
						bedwars["ClientHandler"]:Get("TeleportToLobby"):SendToServer()
					end
				end
			end)
		else
			autoleaveconnection:Disconnect()
		end
	end,
	["HoverText"] = "Leaves if a staff member joins your game or when the match ends."
})
AutoLeaveDelay = AutoLeave.CreateSlider({
	["Name"] = "Delay",
	["Min"] = 0,
	["Max"] = 50,
	["Default"] = 0,
	["Function"] = function() end
})

local justsaid = ""
local leavesaid = false
bedwars["ClientHandler"]:WaitFor("EntityDeathEvent"):andThen(function(p6)
	p6:Connect(function(p7)
		if AutoToxic["Enabled"] then
			if p7.fromEntity and p7.fromEntity == lplr.Character then
				local plr = players:GetPlayerFromCharacter(p7.entityInstance)
				if plr and plr.leaderstats.Bed.Value ~= "✅" and AutoToxicFinalKill["Enabled"] then
					local custommsg = #AutoToxicPhrases2["ObjectList"] > 0 and AutoToxicPhrases2["ObjectList"][math.random(1, #AutoToxicPhrases2["ObjectList"])]
					if custommsg == lastsaid then
						custommsg = #AutoToxicPhrases2["ObjectList"] > 0 and AutoToxicPhrases2["ObjectList"][math.random(1, #AutoToxicPhrases2["ObjectList"])]
					else
						lastsaid = custommsg
					end
					local winstreak = (players:GetPlayerFromCharacter(p7.entityInstance):GetAttribute("WinStreak") > 0 and players:GetPlayerFromCharacter(p7.entityInstance):GetAttribute("WinStreak"))
					if custommsg then
						custommsg = custommsg:gsub("<name>", (plr.DisplayName or plr.Name))
						custommsg = custommsg:gsub("<ws>", winstreak or "0")
					end
					local msg = custommsg or "L "..(plr.DisplayName or plr.Name)..(AutoToxicWinStreak["Enabled"] and winstreak and " : "..winstreak.." winstreak" or "")
					game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(msg, "All")
				end
			end
		end
	end)
end)	
bedwars["ClientStoreHandler"].changed:connect(function(p3, p4)
	if (p3.Game.spectating and not p4.Game.spectating) and leavesaid == false then
		leavesaid = true
		if AutoToxic["Enabled"] and AutoToxicDeath["Enabled"] then
			game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(#AutoToxicPhrases3["ObjectList"] > 0 and AutoToxicPhrases3["ObjectList"][math.random(1, #AutoToxicPhrases3["ObjectList"])] or "My gaming chair expired midfight.", "All")
		end
		if AutoLeave["Enabled"] and #bedwars["ClientStoreHandler"]:getState().Party.members == 0 then
			wait(1 + (AutoLeaveDelay["Value"] / 10))
			bedwars["ClientHandler"]:Get("TeleportToLobby"):SendToServer()
		end
	end
end)

AutoToxic = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
	["Name"] = "AutoToxic",
	["Function"] = function() end
})
AutoToxicGG = AutoToxic.CreateToggle({
	["Name"] = "AutoGG",
	["Function"] = function() end, 
	["Default"] = true
})
AutoToxicWin = AutoToxic.CreateToggle({
	["Name"] = "Win",
	["Function"] = function() end, 
	["Default"] = true
})
AutoToxicDeath = AutoToxic.CreateToggle({
	["Name"] = "Death",
	["Function"] = function() end, 
	["Default"] = true
})
AutoToxicRespond = AutoToxic.CreateToggle({
	["Name"] = "Respond",
	["Function"] = function() end, 
	["Default"] = true
})
AutoToxicFinalKill = AutoToxic.CreateToggle({
	["Name"] = "Final Kill",
	["Function"] = function() end, 
	["Default"] = true
})
AutoToxicWinStreak = AutoToxic.CreateToggle({
	["Name"] = "WinStreak",
	["Function"] = function() end, 
})
AutoToxicAd = AutoToxic.CreateToggle({
	["Name"] = "Sponsor",
	["Function"] = function() end, 
})
AutoToxicPhrases = AutoToxic.CreateTextList({
	["Name"] = "ToxicList",
	["TempText"] = "phrase (win)",
})
AutoToxicPhrases2 = AutoToxic.CreateTextList({
	["Name"] = "ToxicList2",
	["TempText"] = "phrase (kill) <name> <ws>",
})
AutoToxicPhrases3 = AutoToxic.CreateTextList({
	["Name"] = "ToxicList3",
	["TempText"] = "phrase (death)",
})
AutoToxicPhrases4 = AutoToxic.CreateTextList({
	["Name"] = "ToxicList4",
	["TempText"] = "phrase (respond) <name>",
})

GuiLibrary["RemoveObject"]("HitBoxesOptionsButton")
GuiLibrary["RemoveObject"]("SpeedOptionsButton")
local fly = {["Enabled"] = false}
local speedval = {["Value"] = 1}
local speedjump = {["Enabled"] = false}
local bodyvelo
local Scaffold = {["Enabled"] = false}
speed = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
	["Name"] = "Speed",
	["Function"] = function(callback)
		if callback then
			if GuiLibrary["ObjectsThatCanBeSaved"]["FlyOptionsButton"]["Api"]["Enabled"] then
				createwarning("Speed Stopped", "Disable fly to move.", 4)
			end
			BindToRenderStep("Speed", 1, function(delta)
				if isAlive() and matchState ~= 0 then
					local jumpcheck = speedjump["Enabled"] and killauranear and (not Scaffold["Enabled"])
					local bird = (lplr.Character:GetAttribute("Shield_DODO_BIRD") and lplr.Character:GetAttribute("Shield_DODO_BIRD") > 0)
					if (bodyvelo == nil or bodyvelo ~= nil and bodyvelo.Parent ~= lplr.Character.HumanoidRootPart) then
						bodyvelo = Instance.new("BodyVelocity")
						bodyvelo.Parent = lplr.Character.HumanoidRootPart
						bodyvelo.MaxForce = Vector3.new(100000, 0, 100000)
					else
						if bird then
							lplr.Character.Humanoid.WalkSpeed = (50 * (speedval["Value"] / 32)) * (GuiLibrary["ObjectsThatCanBeSaved"]["FlyOptionsButton"]["Api"]["Enabled"] and 0.005 or 1) * (bedwars["RavenTable"]["spawningRaven"] and 0 or 1)
							if (not (lplr.Character.Humanoid:GetState() == Enum.HumanoidStateType.Running or lplr.Character.Humanoid:GetState() == Enum.HumanoidStateType.RunningNoPhysics)) and (not GuiLibrary["ObjectsThatCanBeSaved"]["FlyOptionsButton"]["Api"]["Enabled"]) then
								local newvelo = lplr.Character.Humanoid.MoveDirection * 40
								lplr.Character.HumanoidRootPart.Velocity = Vector3.new(newvelo.X, lplr.Character.HumanoidRootPart.Velocity.Y, newvelo.Z)
							end
						end
						bodyvelo.MaxForce = (bird and Vector3.new(0, 0, 0) or Vector3.new(100000, 0, 100000))
						bodyvelo.Velocity = lplr.Character.Humanoid.MoveDirection * ((GuiLibrary["ObjectsThatCanBeSaved"]["FlyOptionsButton"]["Api"]["Enabled"] and 0 or speedval["Value"]) * 1) * (slowdownspeed and 0.6 or 1) * (bedwars["RavenTable"]["spawningRaven"] and 0 or 1)
					end
					if lplr.Character.Humanoid:GetState() == Enum.HumanoidStateType.Climbing then
						bodyvelo.MaxForce = Vector3.new(0, 0, 0)
					else
						bodyvelo.MaxForce = Vector3.new(100000, 0, 100000)
					end
					if jumpcheck and (not bird) then
						if (lplr.Character.Humanoid:GetState() == Enum.HumanoidStateType.Running or lplr.Character.Humanoid:GetState() == Enum.HumanoidStateType.RunningNoPhysics) and lplr.Character.Humanoid.MoveDirection ~= Vector3.new(0, 0, 0) then
							lplr.Character.HumanoidRootPart.Velocity = Vector3.new(lplr.Character.HumanoidRootPart.Velocity.X, 20, lplr.Character.HumanoidRootPart.Velocity.Z)
						end
					end
				end
			end)
		else
			if bodyvelo then
				bodyvelo:Remove()
			end
			UnbindFromRenderStep("Speed")
		end
	end, 
	["HoverText"] = "Increases your movement."
})
speedval = speed.CreateSlider({
	["Name"] = "Speed",
	["Min"] = 1,
	["Max"] = 32,
	["Function"] = function(val) end,
	["Default"] = 32
})
speedjump = speed.CreateToggle({
	["Name"] = "AutoJump", 
	["Function"] = function() end,
	["Default"] = true
})

GuiLibrary["RemoveObject"]("FlyOptionsButton")
local OldNoFallFunction
local flyspeed = {["Value"] = 40}
local flyverticalspeed = {["Value"] = 40}
local flyupanddown = {["Enabled"] = true}
local olddeflate
local flyposy = 0
local flyrequests = 0
local flytime = 60
local flylimit = false
local flyup = false
local flydown = false
local tnttimer = 0
local flypress
local flyendpress

local function buyballoons()
	if isAlive() and fly["Enabled"] then
		if getItem("balloon") then
			bedwars["BalloonController"]["inflateBalloon"]()
		end
	end
end

bedwars["ClientHandler"]:WaitFor("BalloonPopped"):andThen(function(p6)
	p6:Connect(function(p7)
		buyballoons()
	end)
end)

bedwars["ClientHandler"]:WaitFor("TNT_Explode"):andThen(function(p6)
	p6:Connect(function(p7)
		if isAlive() and (lplr.Character.HumanoidRootPart.Position - p7.position).magnitude < 20 and fly["Enabled"] then
			spawn(function()
				if tnttimer <= 0 then
					tnttimer = 4
					createwarning("TNT Fly", "You can fly for 4 seconds", 4)
					for i = 4, 0, -1 do
						wait(1)
						tnttimer = i
					end
				end
			end)
		end
	end)
end)

fly = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
	["Name"] = "Fly",
	["Function"] = function(callback)
		if callback then
			olddeflate = bedwars["BalloonController"]["deflateBalloon"]
			bedwars["BalloonController"]["deflateBalloon"] = function() end
			if isAlive() then
				spawn(function()
					flyposy = lplr.Character.HumanoidRootPart.Position.Y
					repeat wait() flyposy = lplr.Character.HumanoidRootPart.Position.Y until flyposy == lplr.Character.HumanoidRootPart.Position.Y
					if tnttimer <= 0 then
						buyballoons()
					end
				end)
			end
			flypress = game:GetService("UserInputService").InputBegan:connect(function(input1)
				if flyupanddown["Enabled"] and game:GetService("UserInputService"):GetFocusedTextBox() == nil then
					if input1.KeyCode == Enum.KeyCode.Space then
						flyup = true
					end
					if input1.KeyCode == Enum.KeyCode.LeftShift then
						flydown = true
					end
				end
			end)
			flyendpress = game:GetService("UserInputService").InputEnded:connect(function(input1)
				if input1.KeyCode == Enum.KeyCode.Space then
					flyup = false
				end
				if input1.KeyCode == Enum.KeyCode.LeftShift then
					flydown = false
				end
			end)
			if isAlive() then
				flyposy = lplr.Character.HumanoidRootPart.Position.Y
			end
			BindToRenderStep("Fly", 1, function(delta) 
				if isAlive() and matchState ~= 0 then
					local bird = (lplr.Character:GetAttribute("Shield_DODO_BIRD") and lplr.Character:GetAttribute("Shield_DODO_BIRD") > 0)
					if flyup then
						flyposy = flyposy + (1 * (math.clamp(flyverticalspeed["Value"] - 16, 1, 150) * delta)) * (((lplr.Character:GetAttribute("InflatedBalloons") and lplr.Character:GetAttribute("InflatedBalloons") > 0) or (tnttimer > 0)) and 1 or 0)
					end
					if flydown then
						flyposy = flyposy - (1 * (math.clamp(flyverticalspeed["Value"] - 16, 1, 150) * delta)) * (((lplr.Character:GetAttribute("InflatedBalloons") and lplr.Character:GetAttribute("InflatedBalloons") > 0) or (tnttimer > 0)) and 1 or 0)
					end
					local flypos = (lplr.Character.Humanoid.MoveDirection * (math.clamp(flyspeed["Value"] - 16, 1, 150) * delta)) * (bird and (1.5 * (flyspeed["Value"] / 44)) or 1) * (((lplr.Character:GetAttribute("InflatedBalloons") and lplr.Character:GetAttribute("InflatedBalloons") > 0) or (tnttimer > 0)) and 1 or 0)
					lplr.Character.HumanoidRootPart.Transparency = 1
					lplr.Character.HumanoidRootPart.CFrame = lplr.Character.HumanoidRootPart.CFrame + Vector3.new(flypos.X, (flyposy - lplr.Character.HumanoidRootPart.CFrame.p.Y), flypos.Z)
					lplr.Character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
				end
			end)
		else
			flyup = false
			flydown = false
			flypress:Disconnect()
			flyendpress:Disconnect()
			UnbindFromRenderStep("Fly")
			if isAlive() and lplr.Character:GetAttribute("InflatedBalloons") then
				for i = 1, lplr.Character:GetAttribute("InflatedBalloons") do
					olddeflate()
				end
			end
			bedwars["BalloonController"]["deflateBalloon"] = olddeflate
			olddeflate = nil
		end
	end,
	["HoverText"] = "Makes you go zoom (Balloons or TNT Required)"
})
flyspeed = fly.CreateSlider({
	["Name"] = "Speed",
	["Min"] = 1,
	["Max"] = 44,
	["Function"] = function(val) end, 
	["Default"] = 44
})
flyverticalspeed = fly.CreateSlider({
	["Name"] = "Vertical Speed",
	["Min"] = 1,
	["Max"] = 44,
	["Function"] = function(val) end, 
	["Default"] = 44
})
flyupanddown = fly.CreateToggle({
	["Name"] = "Y Level",
	["Function"] = function() end, 
	["Default"] = true
})

local scaffoldtext = Instance.new("TextLabel")
scaffoldtext.Font = Enum.Font.SourceSans
scaffoldtext.TextSize = 20
scaffoldtext.BackgroundTransparency = 1
scaffoldtext.TextColor3 = Color3.fromRGB(255, 0, 0)
scaffoldtext.Size = UDim2.new(0, 0, 0, 0)
scaffoldtext.Position = UDim2.new(0.5, 0, 0.5, 30)
scaffoldtext.Text = "0"
scaffoldtext.Visible = false
scaffoldtext.Parent = GuiLibrary["MainGui"]
local ScaffoldExpand = {["Value"] = 1}
local ScaffoldDiagonal = {["Enabled"] = false}
local ScaffoldTower = {["Enabled"] = false}
local ScaffoldDownwards = {["Enabled"] = false}
local ScaffoldStopMotion = {["Enabled"] = false}
local ScaffoldBlockCount = {["Enabled"] = false}
local ScaffoldHandCheck = {["Enabled"] = false}
local scaffoldstopmotionval = false
local scaffoldallowed = true

local scaffoldstopmotionpos = Vector3.new(0, 0, 0)

Scaffold = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
	["Name"] = "Scaffold",
	["Function"] = function(callback)
		if callback then
			scaffoldtext.Visible = ScaffoldBlockCount["Enabled"]
			BindToRenderStep("Scaffold", 1, function(delta)
				if isAlive() and (ScaffoldHandCheck["Enabled"] and getEquipped()["Type"] == "block" or (not ScaffoldHandCheck["Enabled"])) then
					if uis:IsKeyDown(Enum.KeyCode.Space) then
						if scaffoldstopmotionval == false then
							scaffoldstopmotionval = true
							scaffoldstopmotionpos = lplr.Character.HumanoidRootPart.CFrame.p
						end
					else
						scaffoldstopmotionval = false
					end
					if getwool() or getEquipped()["Type"] == "block" then
						if ScaffoldTower["Enabled"] and uis:IsKeyDown(Enum.KeyCode.Space) and uis:GetFocusedTextBox() == nil and lplr.Character.HumanoidRootPart.CFrame.p.Y < scaffoldypos then
							lplr.Character.HumanoidRootPart.Velocity = Vector3.new(0, 50, 0)
							if ScaffoldStopMotion["Enabled"] and scaffoldstopmotionval then
								lplr.Character.HumanoidRootPart.CFrame = CFrame.new(Vector3.new(scaffoldstopmotionpos.X, lplr.Character.HumanoidRootPart.CFrame.p.Y, scaffoldstopmotionpos.Z))
							end
						end
					end
					for i = 1, ScaffoldExpand["Value"] do
						local newpos = getScaffold((lplr.Character.Head.Position + ((scaffoldstopmotionval == false and lplr.Character.Humanoid.MoveDirection or Vector3.new(0, 0, 0)) * (i * 3.5))) + Vector3.new(0, -math.floor(lplr.Character.Humanoid.HipHeight * (uis:IsKeyDown(Enum.KeyCode.LeftShift) and ScaffoldDownwards["Enabled"] and 5 or 3)), 0), ScaffoldDiagonal["Enabled"] and (lplr.Character.HumanoidRootPart.Velocity.Y < 2))
						newpos = Vector3.new(newpos.X, math.clamp(newpos.Y - (uis:IsKeyDown(Enum.KeyCode.Space) and ScaffoldTower["Enabled"] and 3 or 0), -999, scaffoldypos), newpos.Z)
						if newpos ~= oldpos then
							local wool, woolamount = getwool()
							if getEquipped()["Type"] == "block" then
								woolamount = getItem(getEquipped()["Object"].Name)["amount"]
							end
							scaffoldtext.Text = (woolamount and tostring(woolamount) or "0")
							if woolamount then
								if woolamount >= 128 then
									scaffoldtext.TextColor3 = Color3.fromRGB(9, 255, 198)
								elseif woolamount >= 64 then
									scaffoldtext.TextColor3 = Color3.fromRGB(255, 249, 18)
								else
									scaffoldtext.TextColor3 = Color3.fromRGB(255, 0, 0)
								end
							end
							if getwool() or getEquipped()["Type"] == "block" then
								lplr.Character.HumanoidRootPart.Anchored = false
								scaffoldBlock(newpos, (getEquipped()["Type"] == "block" and getEquipped()["Object"].Name))
								oldpos = newpos
							end
						end
					end
				end
			end)
		else
			scaffoldtext.Visible = false
			UnbindFromRenderStep("Scaffold")
			scaffoldallowed = true
			oldpos = Vector3.new(0, 0, 0)
			oldpos2 = Vector3.new(0, 0, 0)
			if isAlive() then
				lplr.Character.HumanoidRootPart.Anchored = false
			end
		end
	end, 
	["HoverText"] = "Helps you make bridges/scaffold walk."
})
ScaffoldExpand = Scaffold.CreateSlider({
	["Name"] = "Expand",
	["Min"] = 1,
	["Max"] = 8,
	["Function"] = function(val) end,
	["Default"] = 1
})
ScaffoldDiagonal = Scaffold.CreateToggle({
	["Name"] = "Diagonal", 
	["Function"] = function(callback) end,
	["Default"] = true
})
ScaffoldTower = Scaffold.CreateToggle({
	["Name"] = "Tower", 
	["Function"] = function(callback) 
		if ScaffoldStopMotion["Object"] then
			ScaffoldTower["Object"].ToggleArrow.Visible = callback
			ScaffoldStopMotion["Object"].Visible = callback
		end
	end
})
ScaffoldDownwards  = Scaffold.CreateToggle({
	["Name"] = "Downwards", 
	["Function"] = function(callback) end
})
ScaffoldStopMotion = Scaffold.CreateToggle({
	["Name"] = "Stop Motion",
	["Function"] = function() end
})
ScaffoldStopMotion["Object"].BackgroundTransparency = 0
ScaffoldStopMotion["Object"].BorderSizePixel = 0
ScaffoldStopMotion["Object"].BackgroundColor3 = Color3.fromRGB(20, 20, 20)
ScaffoldStopMotion["Object"].Visible = ScaffoldTower["Enabled"]
ScaffoldBlockCount = Scaffold.CreateToggle({
	["Name"] = "Block Count",
	["Function"] = function(callback) 
		if Scaffold["Enabled"] then
			scaffoldtext.Visible = callback 
		end
	end
})
ScaffoldHandCheck = Scaffold.CreateToggle({
	["Name"] = "Whitelist Only",
	["Function"] = function() end
})

runcode(function()
	local GrabTreeOrbs = {["Enabled"] = false}
	GrabTreeOrbs = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
		["Name"] = "AutoTreeOrb", 
		["Function"] = function(callback)
			if callback then
				spawn(function()
					repeat
						wait()
						local itemdrops = collectionservice:GetTagged("treeOrb")
						for i,v in pairs(itemdrops) do
							if isAlive() and GrabTreeOrbs["Enabled"] and v:FindFirstChild("Spirit") and (lplr.Character.HumanoidRootPart.Position - v.Spirit.Position).magnitude <= 20 then
								if bedwars["ClientHandler"]:Get(bedwars["TreeRemote"]):CallServer({
									treeOrbSecret = v:GetAttribute("TreeOrbSecret")
								}) then
									v:Destroy()
									collectionservice:RemoveTag(v, "treeOrb")
								end
							end
						end
					until GrabTreeOrbs["Enabled"] == false
				end)
			end
		end,
		["HoverText"] = "Automatically grabs tree orbs."
	})
end)


--local BuyArrows = {["Enabled"] = false}
--local BowAura = {["Enabled"] = false}
--local bowaurarange = {["Value"] = 50}
--local BowDelay2 = {["Value"] = 5}
--local BowTargets = {["Value"] = 1}
--BowAura = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("BowAura", function()
	--spawn(function()
		--repeat
		--	wait(BowDelay2["Value"] / 10)
		--	if isAlive() and getEquipped()["Type"] == "bow" then
			--	local targettable = {}
			--	local targetsize = 0
			--	local plrs = GetAllNearestHumanoidToPosition(bowaurarange["Value"], BowTargets["Value"])
			--	for i,v in pairs(plrs) do
			--		wait(0.03)
			--		local bowpos = bedwars["ProjectilePosition"]()
				--	if isPlayerTargetable(v, true, true) and v.Character and v.Character:FindFirstChild("Head") and vischeck(bowpos, v.Character.Head.Position, {lplr.Character, v.Character}) then
			--			targettable[v.Name] = {
				--			["UserId"] = v.UserId,
				--			["Health"] = v.Character.Humanoid.Health,
				--			["MaxHealth"] = v.Character.Humanoid.MaxHealth
					--	}
					--	targetsize = targetsize + 1
					--	game:GetService("ReplicatedStorage").rbxts_include.node_modules.net.out._NetManaged[bedwars["FireProjectile"]]:InvokeServer(getEquipped()["Object"], bowpos, (bowpos - v.Character.Head.Position))
				--	end
			--	end
			--	targetinfo.UpdateInfo(targettable, targetsize)
		--	end
		--until BowAura["Enabled"] == false
--	end)
--end, function() end, true)
--bowaurarange = BowAura.CreateSlider("Bow Range", 1, 70, function(val) end, 70)
--BowDelay2 = BowAura.CreateSlider("Bow Delay", 1, 20, function(val) end, 5)
--BowTargets = BowAura.CreateSlider("Bow Targets", 1, 20, function(val) end, 1)]]

local NoFall = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
	["Name"] = "NoFall",
	["Function"] = function(callback)
		if callback then
			OldNoFallFunction = bedwars["damageTable"]["requestSelfDamage"]
			bedwars["damageTable"]["requestSelfDamage"] = function() end
		else
			bedwars["damageTable"]["requestSelfDamage"] = OldNoFallFunction
		end
	end, 
	["HoverText"] = "Prevents taking fall damage."
})

local NoSlowdown = {["Enabled"] = false}
local OldSetSpeedFunc
NoSlowdown = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
	["Name"] = "NoSlowdown",
	["Function"] = function(callback)
		if callback then
			OldSetSpeedFunc = bedwars["sprintTable"]["setSpeed"]
			bedwars["sprintTable"]["setSpeed"] = function(tab1, val1)
				spawn(function()
					if lplr.Character then
						local hum = lplr.Character:WaitForChild("Humanoid")
						if hum then
							hum.WalkSpeed = (bedwars["sprintTable"].blockSprint and math.clamp(val1 + 6, 0, 100000) or val1)
						end
					end
				end)
			end
		else
			bedwars["sprintTable"]["setSpeed"] = OldSetSpeedFunc
			OldSetSpeedFunc = nil
		end
	end, 
	["HoverText"] = "Prevents slowing down when using items."
})
local healthColorToPosition = {
	[Vector3.new(Color3.fromRGB(255, 28, 0).r,
  Color3.fromRGB(255, 28, 0).g,
  Color3.fromRGB(255, 28, 0).b)] = 0.1;
	[Vector3.new(Color3.fromRGB(250, 235, 0).r,
  Color3.fromRGB(250, 235, 0).g,
  Color3.fromRGB(250, 235, 0).b)] = 0.5;
	[Vector3.new(Color3.fromRGB(27, 252, 107).r,
  Color3.fromRGB(27, 252, 107).g,
  Color3.fromRGB(27, 252, 107).b)] = 0.8;
}
local min = 0.1
local minColor = Color3.fromRGB(255, 28, 0)
local max = 0.8
local maxColor = Color3.fromRGB(27, 252, 107)

local function HealthbarColorTransferFunction(healthPercent)
	if healthPercent < min then
		return minColor
	elseif healthPercent > max then
		return maxColor
	end


	local numeratorSum = Vector3.new(0,0,0)
	local denominatorSum = 0
	for colorSampleValue, samplePoint in pairs(healthColorToPosition) do
		local distance = healthPercent - samplePoint
		if distance == 0 then
			
			return Color3.new(colorSampleValue.x, colorSampleValue.y, colorSampleValue.z)
		else
			local wi = 1 / (distance*distance)
			numeratorSum = numeratorSum + wi * colorSampleValue
			denominatorSum = denominatorSum + wi
		end
	end
	local result = numeratorSum / denominatorSum
	return Color3.new(result.x, result.y, result.z)
end

local BedESP = {["Enabled"] = false}
local BedESPFolder = Instance.new("Folder")
BedESPFolder.Name = "BedESPFolder"
BedESPFolder.Parent = GuiLibrary["MainGui"]
local BedESPColor = {["Value"] = 0.44}
local BedESPTransparency = {["Value"] = 1}
local BedESPOnTop = {["Enabled"] = true}
BedESP = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
	["Name"] = "BedESP",
	["Function"] = function(callback) 
		if callback then
			BindToRenderStep("BedESP", 500, function()
				if bedwars["BedTable"] then
					for i,plr in pairs(bedwars["BedTable"]) do
							local thing
							if plr ~= nil and BedESPFolder:FindFirstChild(plr.Name..tostring(plr.Covers.BrickColor)) then
								thing = BedESPFolder[plr.Name..tostring(plr.Covers.BrickColor)]
								for bedespnumber, bedesppart in pairs(thing:GetChildren()) do
									bedesppart.Visible = false
								end
							end
							
							if plr ~= nil and plr.Parent ~= nil and plr:FindFirstChild("Covers") and plr.Covers.BrickColor ~= lplr.Team.TeamColor then
								if BedESPFolder:FindFirstChild(plr.Name..tostring(plr.Covers.BrickColor)) == nil then
									local Bedfolder = Instance.new("Folder")
									Bedfolder.Name = plr.Name..tostring(plr.Covers.BrickColor)
									Bedfolder.Parent = BedESPFolder
									thing = Bedfolder
									for bedespnumber, bedesppart in pairs(plr:GetChildren()) do
										local boxhandle = Instance.new("BoxHandleAdornment")
										boxhandle.Size = bedesppart.Size + Vector3.new(.01, .01, .01)
										boxhandle.AlwaysOnTop = true
										boxhandle.ZIndex = 10
										boxhandle.Visible = true
										boxhandle.Color3 = bedesppart.Color
										boxhandle.Name = bedespnumber
										boxhandle.Parent = Bedfolder
									end
								end
								for bedespnumber, bedesppart in pairs(thing:GetChildren()) do
									bedesppart.Visible = true
									if plr:GetChildren()[bedespnumber] then
										bedesppart.Adornee = plr:GetChildren()[bedespnumber]
									else
										bedesppart.Adornee = nil
									end
								end
							end
					end
				end
			end)
		else
			UnbindFromRenderStep("BedESP") 
			BedESPFolder:ClearAllChildren()
		end
	end,
	["HoverText"] = "Render Beds through walls" 
})

GuiLibrary["RemoveObject"]("NameTagsOptionsButton")
runcode(function()
	local function removeTags(str)
        str = str:gsub("<br%s*/>", "\n")
        return (str:gsub("<[^<>]->", ""))
    end

	local NameTagsFolder = Instance.new("Folder")
	NameTagsFolder.Name = "NameTagsFolder"
	NameTagsFolder.Parent = GuiLibrary["MainGui"]
	players.PlayerRemoving:connect(function(plr)
		if NameTagsFolder:FindFirstChild(plr.Name) then
			NameTagsFolder[plr.Name]:Remove()
		end
	end)
	local NameTagsColor = {["Value"] = 0.44}
	local NameTagsDisplayName = {["Enabled"] = false}
	local NameTagsHealth = {["Enabled"] = false}
	local NameTagsDistance = {["Enabled"] = false}
	local NameTagsShowInventory = {["Enabled"] = false}
	local NameTags = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
		["Name"] = "NameTags",
		["Function"] = function(callback) 
			if callback then
				BindToRenderStep("NameTags", 500, function()
					for i,plr in pairs(players:GetChildren()) do
							local thing
							if NameTagsFolder:FindFirstChild(plr.Name) then
								thing = NameTagsFolder[plr.Name]
								thing.Visible = false
							else
								thing = Instance.new("TextLabel")
								thing.BackgroundTransparency = 0.5
								thing.BackgroundColor3 = Color3.new(0, 0, 0)
								thing.BorderSizePixel = 0
								thing.Visible = false
								thing.RichText = true
								thing.Name = plr.Name
								thing.Font = Enum.Font.SourceSans
								thing.TextSize = 14
								if plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character:FindFirstChild("HumanoidRootPart") then
									local bountyhunter = lplr.PlayerGui:FindFirstChildWhichIsA("BillboardGui")
									local istarget = false
									if bountyhunter and bountyhunter.Adornee.Parent.Name == plr.Name then
										istarget = true
									end
									local rawText = (istarget and "[TARGET] " or "")..(NameTagsDistance["Enabled"] and isAlive() and '['..math.floor((lplr.Character.HumanoidRootPart.Position - plr.Character.HumanoidRootPart.Position).magnitude)..'] ' or '')..(NameTagsDisplayName["Enabled"] and plr.DisplayName ~= nil and plr.DisplayName or plr.Name)..(NameTagsHealth["Enabled"] and " "..math.floor(plr.Character.Humanoid.Health) or "")
									local color = HealthbarColorTransferFunction(plr.Character.Humanoid.Health / plr.Character.Humanoid.MaxHealth)
									local modifiedText = (istarget and '<font color="rgb(255, 0, 0)">[TARGET]</font> ' or '')..(NameTagsDistance["Enabled"] and isAlive() and '<font color="rgb(85, 255, 85)">[</font>'..math.floor((lplr.Character.HumanoidRootPart.Position - plr.Character.HumanoidRootPart.Position).magnitude)..'<font color="rgb(85, 255, 85)">]</font> ' or '')..(NameTagsDisplayName["Enabled"] and plr.DisplayName ~= nil and plr.DisplayName or plr.Name)..(NameTagsHealth["Enabled"] and ' <font color="rgb('..tostring(math.floor(color.R * 255))..','..tostring(math.floor(color.G * 255))..','..tostring(math.floor(color.B * 255))..')">'..math.floor(plr.Character.Humanoid.Health).."</font>" or '')
									local nametagSize = game:GetService("TextService"):GetTextSize(rawText, thing.TextSize, thing.Font, Vector2.new(100000, 100000))
									thing.Size = UDim2.new(0, nametagSize.X + 4, 0, nametagSize.Y)
									thing.Text = modifiedText
								else
									local nametagSize = game:GetService("TextService"):GetTextSize(plr.Name, thing.TextSize, thing.Font, Vector2.new(100000, 100000))
									thing.Size = UDim2.new(0, nametagSize.X + 4, 0, nametagSize.Y)
									thing.Text = plr.Name
								end
								thing.TextColor3 = getPlayerColor(plr) or Color3.fromHSV(NameTagsColor["Value"], 1, 1)
								thing.Parent = NameTagsFolder
								local hand = Instance.new("ImageLabel")
								hand.Size = UDim2.new(0, 30, 0, 30)
								hand.Name = "Hand"
								hand.BackgroundTransparency = 1
								hand.Position = UDim2.new(0, -30, 0, -30)
								hand.Image = ""
								hand.Parent = thing
								local helmet = hand:Clone()
								helmet.Name = "Helmet"
								helmet.Position = UDim2.new(0, 5, 0, -30)
								helmet.Parent = thing
								local chest = hand:Clone()
								chest.Name = "Chestplate"
								chest.Position = UDim2.new(0, 35, 0, -30)
								chest.Parent = thing
								local boots = hand:Clone()
								boots.Name = "Boots"
								boots.Position = UDim2.new(0, 65, 0, -30)
								boots.Parent = thing
							end
							
							if isAlive(plr) and plr ~= lplr then
								local headPos, headVis = cam:WorldToViewportPoint((plr.Character.HumanoidRootPart:GetRenderCFrame() * CFrame.new(0, plr.Character.Head.Size.Y + plr.Character.HumanoidRootPart.Size.Y, 0)).Position)
								headPos = headPos * (1 / GuiLibrary["MainRescale"].Scale)
								
								if headVis then
									local inventory = bedwars["getInventory"](plr)
									if inventory.hand then
										thing.Hand.Image = bedwars["getIcon"](inventory.hand, NameTagsShowInventory["Enabled"])
									else
										thing.Hand.Image = ""
									end
									if inventory.armor[4] then
										thing.Helmet.Image = bedwars["getIcon"](inventory.armor[4], NameTagsShowInventory["Enabled"])
									else
										thing.Helmet.Image = ""
									end
									if inventory.armor[5] then
										thing.Chestplate.Image = bedwars["getIcon"](inventory.armor[5], NameTagsShowInventory["Enabled"])
									else
										thing.Chestplate.Image = ""
									end
									if inventory.armor[6] then
										thing.Boots.Image = bedwars["getIcon"](inventory.armor[6], NameTagsShowInventory["Enabled"])
									else
										thing.Boots.Image = ""
									end
									local bountyhunter = lplr.PlayerGui:FindFirstChildWhichIsA("BillboardGui")
									local istarget = false
									if bountyhunter and bountyhunter.Adornee.Parent.Name == plr.Name then
										istarget = true
									end
									local displaynamestr = (NameTagsDisplayName["Enabled"] and plr.DisplayName ~= nil and plr.DisplayName or plr.Name)
									local displaynamestr2 = (NameTagsDisplayName["Enabled"] and plr.DisplayName ~= nil and plr.DisplayName or plr.Name)
									local blocksaway = math.floor(((isAlive() and lplr.Character.HumanoidRootPart.Position or Vector3.new(0,0,0)) - plr.Character.HumanoidRootPart.Position).magnitude / 3)
									local rawText = (istarget and "[TARGET] " or "")..(NameTagsDistance["Enabled"] and isAlive() and "["..blocksaway.."] " or "")..displaynamestr..(NameTagsHealth["Enabled"] and " "..math.floor(plr.Character.Humanoid.Health) or "")
									local color = HealthbarColorTransferFunction(plr.Character.Humanoid.Health / plr.Character.Humanoid.MaxHealth)
									local modifiedText = (istarget and '<font color="rgb(255, 0, 0)">[TARGET]</font> ' or '')..(NameTagsDistance["Enabled"] and isAlive() and '<font color="rgb(85, 255, 85)">[</font><font color="rgb(255, 255, 255)">'..blocksaway..'</font><font color="rgb(85, 255, 85)">]</font> ' or '')..displaynamestr2..(NameTagsHealth["Enabled"] and ' <font color="rgb('..tostring(math.floor(color.R * 255))..','..tostring(math.floor(color.G * 255))..','..tostring(math.floor(color.B * 255))..')">'..math.floor(plr.Character.Humanoid.Health).."</font>" or '')
									local nametagSize = game:GetService("TextService"):GetTextSize(rawText, thing.TextSize, thing.Font, Vector2.new(100000, 100000))
									thing.Size = UDim2.new(0, nametagSize.X + 4, 0, nametagSize.Y)
									thing.Text = modifiedText
									thing.TextColor3 = getPlayerColor(plr) or Color3.fromHSV(NameTagsColor["Value"], 1, 1)
									thing.Visible = headVis
									thing.Position = UDim2.new(0, headPos.X - thing.Size.X.Offset / 2, 0, (headPos.Y - thing.Size.Y.Offset) - 36)
								end
							end
						end

				end)
			else
				UnbindFromRenderStep("NameTags") 
				NameTagsFolder:ClearAllChildren()
			end
		end
	})
	NameTagsColor = NameTags.CreateColorSlider({
		["Name"] = "Player Color",
		["Function"] = function(val) end
	})
	NameTagsDisplayName = NameTags.CreateToggle({
		["Name"] = "Use Display Name",
		["Function"] = function() end,
		["Default"] = true
	})
	NameTagsHealth = NameTags.CreateToggle({
		["Name"] = "Health",
		["Function"] = function() end,
		["Default"] = true
	})
	NameTagsDistance = NameTags.CreateToggle({
		["Name"] = "Distance",
		["Function"] = function() end,
	})
	NameTagsShowInventory = NameTags.CreateToggle({
		["Name"] = "Equipment",
		["Function"] = function() end,
		["Default"] = true
	})
end)

GuiLibrary["RemoveObject"]("NickHiderOptionsButton")
runcode(function()
	local NickHider = {["Enabled"] = false}
	local NickHiderBox = {["Value"] = ""}
	local newname
	local newid
	local newdisplayname
	local nickeduser = {}
	local nickconnections = {}
	local nickedmodel 
	local oldmodel = {}
	local nickhidercharadded
	local nickhiderdescendantsadded
	local OldNameCall = nil

	local function findclosestitem(name)
		local close
		return close
	end

	local function dostuff()
		spawn(function()
			local hum = lplr.Character:WaitForChild("Humanoid")
			local rootpart = lplr.Character:WaitForChild("HumanoidRootPart")
			local changedface = false
			for i,v in pairs(lplr.Character:GetChildren()) do
				if v:IsA("Accessory") and v:GetAttribute("ArmorSlot") == nil and v:GetAttribute("ItemData") == nil then
					v.Handle.Transparency = 1
				end
				if v:IsA("LocalScript") and v.Name:find("Animate") then
					oldmodel["animate"] = v
				end
				if v:IsA("BodyColors") then
					oldmodel["bodycolors"] = v
				end
				if v.Name == "Head" and v:FindFirstChild("face") then
					oldmodel["face"] = v.face
				end
				if v:IsA("Shirt") then
					oldmodel["shirt"] = v
				end
				if v:IsA("Pants") then
					oldmodel["pants"] = v
				end
			end
			for i,v in pairs(nickedmodel:GetChildren()) do
				if v:IsA("Folder") and v.Name:match("R15") and oldmodel["animate"] then
					for i2,v2 in pairs(v:GetChildren()) do
						if oldmodel["animate"]:FindFirstChild(v2.Name) then
							oldmodel["animate"][v2.Name]:Remove()
						end
						v2:Clone().Parent = oldmodel["animate"]
					end
				end
				if v:IsA("Shirt") then
					if oldmodel["shirt"] then
						oldmodel["shirt"].ShirtTemplate = v.ShirtTemplate
					else
						v:Clone().Parent = lplr.Character
					end
				end
				if v:IsA("Pants") then
					if oldmodel["pants"] then
						oldmodel["pants"].PantsTemplate = v.PantsTemplate
					else
						v:Clone().Parent = lplr.Character
					end
				end
				if v.Name == "face" and oldmodel["face"] then
					oldmodel["face"].Texture = v.Texture
					changedface = true
				end
				if v:IsA("BodyColors") and oldmodel["bodycolors"] then
					oldmodel["bodycolors"].HeadColor3 = v.HeadColor3
					oldmodel["bodycolors"].LeftArmColor3 = v.LeftArmColor3
					oldmodel["bodycolors"].RightArmColor3 = v.RightArmColor3
					oldmodel["bodycolors"].LeftLegColor3 = v.LeftLegColor3
					oldmodel["bodycolors"].RightLegColor3 = v.RightLegColor3
					oldmodel["bodycolors"].TorsoColor3 = v.TorsoColor3
				end
				if v:IsA("Accessory") then
					local temp = v:Clone()
					lplr.Character.Humanoid:AddAccessory(temp)
				end
			end
			if oldmodel["face"] and changedface == false then
				oldmodel["face"].Texture = "rbxasset://textures/face.png"
			end
			bedwars["WeldTable"].weldCharacterAccessories(lplr.Character)
		end)
	end

	local function plrthing(obj, property, revert)
		if (NickHider["Enabled"] or revert) and nickeduser ~= {} and nickeduser ~= nil then
			obj[property] = obj[property]:gsub((revert and newname or lplr.Name), (revert and lplr.Name or nickeduser["Username"]))
			obj[property] = obj[property]:gsub((revert and newdisplayname or lplr.DisplayName), (revert and lplr.DisplayName or nickeduser["DisplayName"]))
			obj[property] = obj[property]:gsub((revert and newid or lplr.UserId), (revert and lplr.UserId or nickeduser["Id"]))
		end
	end

	local function newobj(v, revert)
		if v:IsA("TextLabel") or v:IsA("TextButton") then
			plrthing(v, "Text", revert)
			if (not revert) then
				table.insert(nickconnections, v:GetPropertyChangedSignal("Text"):connect(function()
					plrthing(v, "Text", revert)
				end))
			end
		end
		if v:IsA("ImageLabel") then
			plrthing(v, "Image", revert)
			if (not revert) then
				table.insert(nickconnections, v:GetPropertyChangedSignal("Image"):connect(function()
					plrthing(v, "Image", revert)
				end))
			end
		end
	end

	NickHider = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
		["Name"] = "NickHider",
		["Function"] = function(callback)
			if callback and nickeduser ~= {} and nickeduser ~= nil and NickHiderBox["Value"] ~= "" then
				if not OldNameCall then
					OldNameCall = hookmetamethod(game, "__namecall", function(...)
						local Args = {...}
						local NamecallMethod = getnamecallmethod()
					
						if not checkcaller() and #Args >= 2 and Args[1] == textservice and NamecallMethod == "GetTextSize" and NickHider["Enabled"] and nickeduser ~= {} and nickeduser ~= nil then
							Args[2] = Args[2]:gsub(lplr.Name, nickeduser["Username"])
							Args[2] = Args[2]:gsub(lplr.DisplayName, nickeduser["DisplayName"])
						end
					
						return OldNameCall(unpack(Args))
					end)
				end
				nickedmodel = game:GetService('Players'):GetCharacterAppearanceAsync(nickeduser.Id)
				newname = nickeduser["Username"]
				newdisplayname = nickeduser["DisplayName"]
				newid = nickeduser["Id"]
				repeat wait() until nickedmodel ~= nil
				if isAlive() then
					dostuff()
				end
				for i,v in pairs(game:GetDescendants()) do
					newobj(v)
				end
				nickhidercharadded = lplr.CharacterAdded:connect(dostuff)
				nickhiderdescendantsadded = game.DescendantAdded:connect(newobj)
			else
				if nickhidercharadded then
					nickhidercharadded:Disconnect()
				end
				if nickhiderdescendantsadded then
					nickhiderdescendantsadded:Disconnect()
				end
				if nickeduser == {} or nickeduser == nil or NickHiderBox["Value"] ~= "" then
					createwarning("NickHider", "No User or Invalid User Id", 4)
				end
				nickedmodel = game:GetService('Players'):GetCharacterAppearanceAsync(lplr.UserId)
				repeat wait() until nickedmodel ~= nil
				if isAlive() then
					dostuff()
				end
				for i2,v2 in pairs(nickconnections) do
					v2:Disconnect()
				end
				for i,v in pairs(game:GetDescendants()) do
					newobj(v, true)
				end
			end
		end,
		["HoverText"] = "Disguises as the UserId in the text box (Client Side)"
	})
	NickHiderBox = NickHider.CreateTextBox({
		["Name"] = "UserBox",
		["TempText"] = "User (userid)",
		["FocusLost"] = function()
			local success, result = pcall(function()
				return game:GetService("UserService"):GetUserInfosByUserIdsAsync({ tonumber(NickHiderBox["Value"]) })
			end)
			 
			if success and #result > 0 then
				nickeduser = result[1]
				if NickHider["Enabled"] then
					NickHider["ToggleButton"](false)
					NickHider["ToggleButton"](true)
				end
			else
				if NickHider["Enabled"] then
					createwarning("NickHider", "Invalid User Id", 4)
				end
			end
		end
	})
end)

runcode(function()
	local SwitchKit = {["Enabled"] = false}
	local SwitchKitDropdown = {["Value"] = nil}
	SwitchKit = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
		["Name"] = "SwitchKit",
		["Function"] = function(callback)
			if callback then
				if GuiLibrary["ObjectsThatCanBeSaved"]["Blatant modeToggle"]["Api"]["Enabled"] then
					if table.find(ownedkits, SwitchKitDropdown["Value"]) then
						createwarning("Bedwars", "Switched kit to "..SwitchKitDropdown["Value"], 3)
						bedwars["ClientHandler"]:Get("BedwarsActivateKit"):CallServerAsync(SwitchKitDropdown["Value"] and {
							kit = SwitchKitDropdown["Value"]
						} or {}):andThen(function(p11)
							if p11 then
								bedwars["SoundManager"]:playSound(19)
								if SwitchKitDropdown["Value"] then
									bedwars["ClientStoreHandler"]:dispatch({
										type = "SetBedwarsKit", 
										kit = SwitchKitDropdown["Value"]
									})
								end
							end
						end)
					else
						createwarning("Bedwars", "Selected Kit not owned", 3)
					end
				else
					createwarning("Bedwars", "Requires Blatant mode", 3)
				end
				SwitchKit["ToggleButton"](false)
			end
		end, 
		["HoverText"] = "USE ALTS WHEN USING THIS \nIT CAN BE PATCHED AT ANY MOMENT (Blatant Mode Required)"
	})
	SwitchKitDropdown = SwitchKit.CreateDropdown({
		["Name"] = "Kit", 
		["List"] = ownedkits,
		["Function"] = function(val) end
	})
	spawn(function()
		repeat wait() until matchState ~= 0
		ownedkits = {}
		for i2,v2 in pairs(bedwars["ClientStoreHandler"]:getState().Bedwars.ownedKits) do
            table.insert(ownedkits, v2)
        end
        for i3,v3 in pairs(bedwars["BedwarsKits"].FreeKits) do
            table.insert(ownedkits, v3)
        end
		SwitchKitDropdown["UpdateList"](ownedkits)
		SwitchKitDropdown["Value"] = ownedkits[1]
	end)
end)

runcode(function()
	local WinstreakTracker = GuiLibrary.CreateCustomWindow({
		["Name"] = "WinstreakTracker", 
		["Icon"] = "vape/assets/RadarIcon1.png",
		["IconSize"] = 16,
		["Bypass"] = true
	})
	WinstreakTracker.GetCustomChildren().Position = UDim2.new(0, 0, -1, 0)
	local onetext = Instance.new("TextLabel")
	onetext.Parent = WinstreakTracker.GetCustomChildren()
	onetext.Size = UDim2.new(1, 0, 1, 0)
	onetext.Position = UDim2.new(1, -154, 0, 35)
	onetext.TextColor3 = Color3.new(1, 1, 1)
	onetext.RichText = true
	onetext.BackgroundTransparency = 1
	onetext.TextXAlignment = Enum.TextXAlignment.Left
	onetext.TextYAlignment = Enum.TextYAlignment.Bottom
	onetext.BorderSizePixel = 0
	onetext.BackgroundColor3 = Color3.new(0, 0, 0)
	onetext.Font = Enum.Font.SourceSans
	onetext.Text = "7GrandDad : 1"
	onetext.TextSize = 20
	local onetext2 = Instance.new("TextLabel")
	onetext2.Name = "ExtraText"
	onetext2.Parent = onetext
	onetext2.Size = UDim2.new(1, 0, 1, 0)
	onetext2.Position = UDim2.new(0, 1, 0, 1)
	onetext2.BorderSizePixel = 0
	onetext2.Visible = false
	onetext2.ZIndex = 0
	onetext2.Text = ""
	onetext2.BackgroundTransparency = 1
	onetext2.TextTransparency = 0.5
	onetext2.TextXAlignment = Enum.TextXAlignment.Left
	onetext2.TextYAlignment = Enum.TextYAlignment.Bottom
	onetext2.TextColor3 = Color3.new(0, 0, 0)
	onetext2.Font = Enum.Font.SourceSans
	onetext2.TextSize = 20
	WinstreakTracker.GetCustomChildren().Parent:GetPropertyChangedSignal("Position"):connect(function()
		if (WinstreakTracker.GetCustomChildren().Parent.Position.X.Offset + WinstreakTracker.GetCustomChildren().Parent.Size.X.Offset / 2) >= (cam.ViewportSize.X / 2) then
			onetext.TextXAlignment = Enum.TextXAlignment.Right
			onetext2.TextXAlignment = Enum.TextXAlignment.Right
			onetext2.Position = UDim2.new(0, 1, 0, 1)
			onetext.Position = UDim2.new(1, -154, 0, -(onetext.Size.Y.Offset - 60))
		else
			onetext.TextXAlignment = Enum.TextXAlignment.Left
			onetext2.TextXAlignment = Enum.TextXAlignment.Left
			onetext2.Position = UDim2.new(0, 4, 0, 1)
			onetext.Position = UDim2.new(0, 0, 0, -(onetext.Size.Y.Offset - 60))
		end
	end)
	if WinstreakTracker.GetCustomChildren().Parent then
		if (WinstreakTracker.GetCustomChildren().Parent.Position.X.Offset + WinstreakTracker.GetCustomChildren().Parent.Size.X.Offset / 2) >= (cam.ViewportSize.X / 2) then
			onetext.TextXAlignment = Enum.TextXAlignment.Right
			onetext2.Position = UDim2.new(0, 1, 0, 1)
			onetext2.TextXAlignment = Enum.TextXAlignment.Right
			onetext.Position = UDim2.new(1, -154, 0, -(onetext.Size.Y.Offset - 60))
		else
			onetext.TextXAlignment = Enum.TextXAlignment.Left
			onetext2.TextXAlignment = Enum.TextXAlignment.Left
			onetext2.Position = UDim2.new(0, 4, 0, 1)
			onetext.Position = UDim2.new(0, 0, 0, -(onetext.Size.Y.Offset - 60))
		end
	end
	
	onetext.Position = UDim2.new(0, 0, 0, 35)
	local playeraddedwinstreak
	local textwithoutthing = ""
	local WinstreakTrackerColor = {["Value"] = 0.44, ["RainbowValue"] = false}
	local WinstreakTrackerShadow = {["Enabled"] = false}

	local function updatecolor(val)
		local newtext = ""
		local newfirst = false
		for i2,v2 in pairs(textwithoutthing:split("\n")) do
			local rainbowsub = 2
			local rainbowcolor = val + (WinstreakTrackerColor["RainbowValue"] and (-0.015 * i2) or 0)
			if rainbowcolor < 0 then rainbowsub = 3 rainbowcolor = rainbowcolor * 0.25 end
			local str = tostring(rainbowcolor)
			local newcol = tonumber("0"..string.sub(str, rainbowsub, string.len(str)))
			local newcolor = Color3.fromHSV(newcol, 0.7, 0.9)
			newtext = newtext..(newfirst and "\n" or " ")..'<font color="rgb('..tostring(math.floor(newcolor.R * 255))..","..tostring(math.floor(newcolor.G * 255))..","..tostring(math.floor(newcolor.B * 255))..')">'..v2..'</font>'
			newfirst = true
		end
		onetext.Text = newtext
	end

	local WinstreakTrackerButton = {["Enabled"] = false}
	WinstreakTrackerButton = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
		["Name"] = "WinstreakTracker",
		["Function"] = function(callback)
			WinstreakTracker.SetVisible(callback)
			if callback then
				spawn(function()
					local str = ""
					repeat
						wait(3)
						str = ""
						for i,v in pairs(players:GetChildren()) do
							repeat wait() until v:GetAttribute("WinStreak") ~= nil
							if v:GetAttribute("WinStreak") and v:GetAttribute("WinStreak") > 0 and v ~= lplr then
								str = str..(v.DisplayName or v.Name).." : "..v:GetAttribute("WinStreak").."\n"
							end
						end
						onetext.Text = str
						onetext2.Text = str
						textwithoutthing = str
						updatecolor(WinstreakTrackerColor["Value"])
						local newsize = game:GetService("TextService"):GetTextSize(str, onetext.TextSize, onetext.Font, Vector2.new(1000000, 1000000))
						onetext.Size = UDim2.new(0, 154, 0, newsize.Y)
						onetext.Position = UDim2.new(onetext.Position.X.Scale, onetext.Position.X.Offset, onetext.Position.Y.Scale, -(newsize.Y - 60))
					until WinstreakTrackerButton["Enabled"] == false
				end)
			end
		end,
		["HoverText"] = "Shows a list of WinStreaks"
	})
	WinstreakTrackerColor = WinstreakTrackerButton.CreateColorSlider({
		["Name"] = "Text Color",
		["Function"] = function(val)
			updatecolor(val)
		end
	})
	WinstreakTrackerShadow = WinstreakTrackerButton.CreateToggle({
		["Name"] = "Shadow", 
		["Function"] = function(callback) onetext2.Visible = callback end
	})
end)